<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI QRã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚° - ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹å†ç”Ÿç‰ˆ</title>
    <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://unpkg.com/qrious@4.0.2/dist/qrious.min.js"></script>
    <script src="https://unpkg.com/@tonejs/midi@2.0.28/build/Midi.js"></script>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h2 {
            margin-top: 0;
            color: #333;
        }

        video,
        canvas {
            width: 100%;
            max-width: 400px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }

        .controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        input[type="file"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 80px;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status.playing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .flash-display {
            text-align: center;
            padding: 20px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qr-canvas {
            border: 2px solid #333;
            max-width: 100%;
        }

        .label {
            font-weight: bold;
            margin-right: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- å—ä¿¡ãƒ»å†ç”Ÿå´ -->
        <div class="panel">
            <h2>ğŸµ MIDIå—ä¿¡ãƒ»å†ç”Ÿ</h2>

            <video id="video" autoplay></video>
            <canvas id="canvas" style="display: none;"></canvas>

            <div class="controls">
                <button id="startBtn">ã‚«ãƒ¡ãƒ©é–‹å§‹</button>
                <button id="stopBtn" disabled>åœæ­¢</button>
                <button id="clearBtn">ã‚¯ãƒªã‚¢</button>
                <button id="stopPlayBtn" disabled>å†ç”Ÿåœæ­¢</button>
            </div>

            <div class="controls">
                <span class="label">å¤§ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º:</span>
                <input type="number" id="bigChunkSize" value="4" min="2" max="10" step="1">
                <span>ãƒãƒ£ãƒ³ã‚¯</span>
                <label>
                    <input type="checkbox" id="debugMode">
                    ãƒ‡ãƒãƒƒã‚°
                </label>
            </div>

            <div id="receiverStatus" class="status info">ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„</div>

            <div class="progress-bar">
                <div id="receivedProgress" class="progress-fill" style="background: #bee5eb;"></div>
                <div id="playProgress" class="progress-fill"
                    style="background: #007bff; position: absolute; top: 0; z-index: 2;"></div>
            </div>
        </div>

        <!-- é€ä¿¡å´ -->
        <div class="panel">
            <h2>ğŸ“¤ MIDIé€ä¿¡</h2>

            <div class="controls">
                <input type="file" id="midiFile" accept=".mid,.midi" />
                <button id="loadMidiBtn">MIDIèª­ã¿è¾¼ã¿</button>
            </div>

            <div class="controls">
                <span class="label">ãƒãƒ£ãƒ³ã‚¯éŸ³ç¬¦æ•°:</span>
                <input type="number" id="chunkNoteCount" value="20" min="10" max="50" step="5">
                <span class="label">é€ä¿¡FPS:</span>
                <input type="number" id="flashFPS" value="10" min="5" max="20">
            </div>

            <div class="controls">
                <button id="generateBtn" disabled>QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ</button>
                <button id="flashBtn" disabled>ãƒ•ãƒ©ãƒƒã‚·ãƒ¥é–‹å§‹</button>
                <button id="stopFlashBtn" disabled>ãƒ•ãƒ©ãƒƒã‚·ãƒ¥åœæ­¢</button>
            </div>

            <div id="senderStatus" class="status info">MIDIãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</div>

            <div class="flash-display">
                <canvas id="qrCanvas" class="qr-canvas"></canvas>
            </div>

            <div class="controls">
                <span class="label">é€²è¡Œ:</span>
                <span id="progressDisplay">0 / 0</span>
                <span class="label">ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º:</span>
                <span id="dataSizeDisplay">0B</span>
            </div>
        </div>
    </div>

    <script>
        class MIDIQRStreaming {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.qrCanvas = document.getElementById('qrCanvas');

                // å—ä¿¡å´
                this.isScanning = false;
                this.receivedChunks = new Map();
                this.bigChunks = new Map();
                this.isPlaying = false;
                this.synth = null;
                this.playbackStartTime = null;
                this.currentPlaybackTime = 0;

                // æ™‚é–“ãƒ™ãƒ¼ã‚¹é€²æ—ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
                this.totalMusicDuration = 0;        // æ¥½æ›²å…¨ä½“ã®é•·ã•ï¼ˆç§’ï¼‰
                this.receivedMusicDuration = 0;     // å—ä¿¡æ¸ˆã¿éƒ¨åˆ†ã®é•·ã•ï¼ˆç§’ï¼‰
                this.estimatedTotalDuration = 0;    // æ¨å®šã•ã‚Œã‚‹æ¥½æ›²å…¨ä½“ã®é•·ã•

                // ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°å†ç”Ÿç”¨
                this.noteQueue = []; // æœªå†ç”ŸéŸ³ç¬¦ã®ã‚­ãƒ¥ãƒ¼
                this.playedNotes = []; // å†ç”Ÿæ¸ˆã¿éŸ³ç¬¦ã®å±¥æ­´
                this.playbackScheduler = null;
                this.lastProcessedChunkIndex = -1;

                // é€ä¿¡å´
                this.originalMidi = null;
                this.qrChunks = [];
                this.flashInterval = null;
                this.currentChunkIndex = 0;

                this.initializeElements();
                this.setupEventListeners();
            }

            initializeElements() {
                // å—ä¿¡å´
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.stopPlayBtn = document.getElementById('stopPlayBtn');
                this.debugMode = document.getElementById('debugMode');
                this.bigChunkSize = document.getElementById('bigChunkSize');
                this.receiverStatus = document.getElementById('receiverStatus');
                this.receivedProgress = document.getElementById('receivedProgress');
                this.playProgress = document.getElementById('playProgress');

                // é€ä¿¡å´
                this.midiFile = document.getElementById('midiFile');
                this.loadMidiBtn = document.getElementById('loadMidiBtn');
                this.chunkNoteCount = document.getElementById('chunkNoteCount');
                this.flashFPS = document.getElementById('flashFPS');
                this.generateBtn = document.getElementById('generateBtn');
                this.flashBtn = document.getElementById('flashBtn');
                this.stopFlashBtn = document.getElementById('stopFlashBtn');
                this.senderStatus = document.getElementById('senderStatus');
                this.progressDisplay = document.getElementById('progressDisplay');
                this.dataSizeDisplay = document.getElementById('dataSizeDisplay');
            }

            setupEventListeners() {
                // å—ä¿¡å´
                this.startBtn.addEventListener('click', () => this.startCamera());
                this.stopBtn.addEventListener('click', () => this.stopCamera());
                this.clearBtn.addEventListener('click', () => this.clearData());
                this.stopPlayBtn.addEventListener('click', () => this.stopMidi());

                // é€ä¿¡å´
                this.loadMidiBtn.addEventListener('click', () => this.loadMidiFile());
                this.generateBtn.addEventListener('click', () => this.generateQRCodes());
                this.flashBtn.addEventListener('click', () => this.startFlashing());
                this.stopFlashBtn.addEventListener('click', () => this.stopFlashing());
            }

            async initializeAudio() {
                try {
                    // é«˜å“è³ªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è¨­å®š
                    await Tone.start();

                    // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æœ€é©åŒ–
                    if (Tone.context.state !== 'running') {
                        await Tone.context.resume();
                    }

                    // ã‚ˆã‚Šå¤§ããªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®šï¼ˆãƒã‚¤ã‚ºè»½æ¸›ï¼‰
                    if (Tone.context.baseLatency !== undefined) {
                        console.log(`ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªé…å»¶: ${(Tone.context.baseLatency * 1000).toFixed(1)}ms`);
                    }

                    // é«˜å“è³ªãƒªãƒŸãƒƒã‚¿ãƒ¼/ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ãƒã‚§ãƒ¼ãƒ³ã®æ§‹ç¯‰
                    // ã“ã‚Œã¯ã€ŒéŸ³ã®äº¤é€šæ•´ç†ä¿‚ã€ã¨ã—ã¦æ©Ÿèƒ½ã—ã¾ã™

                    // 1. ã‚½ãƒ•ãƒˆã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ãƒªãƒŸãƒƒã‚¿ãƒ¼ï¼ˆæ­ªã¿é˜²æ­¢ã®æœ€å¾Œã®ç ¦ï¼‰
                    this.limiter = new Tone.Limiter(-1); // -1dBã§åˆ¶é™

                    // 2. ãƒãƒ«ãƒãƒãƒ³ãƒ‰ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ï¼ˆå‘¨æ³¢æ•°å¸¯åŸŸåˆ¥ã®éŸ³é‡åˆ¶å¾¡ï¼‰
                    this.compressor = new Tone.MultibandCompressor({
                        low: {
                            threshold: -12,   // ä½éŸ³åŸŸã®åœ§ç¸®é–‹å§‹ãƒ¬ãƒ™ãƒ«
                            ratio: 6,         // åœ§ç¸®æ¯”
                            attack: 0.003,    // ç´ æ—©ã„åå¿œ
                            release: 0.1      // è‡ªç„¶ãªè§£æ”¾
                        },
                        mid: {
                            threshold: -18,   // ä¸­éŸ³åŸŸï¼ˆæœ€ã‚‚æ•æ„Ÿãªå¸¯åŸŸï¼‰
                            ratio: 4,
                            attack: 0.002,
                            release: 0.08
                        },
                        high: {
                            threshold: -15,   // é«˜éŸ³åŸŸ
                            ratio: 8,         // ã‚ˆã‚Šå¼·ã„åœ§ç¸®ï¼ˆã‚·ãƒ£ãƒ¼ãƒ—ã•ã‚’æŠ‘åˆ¶ï¼‰
                            attack: 0.001,
                            release: 0.05
                        }
                    });

                    // 3. ãƒã‚¹ã‚¿ãƒ¼ãƒœãƒªãƒ¥ãƒ¼ãƒ ï¼ˆå…¨ä½“ã®éŸ³é‡èª¿æ•´ï¼‰
                    this.masterVolume = new Tone.Volume(-18); // ã•ã‚‰ã«å®‰å…¨ã« -18dB

                    // 4. é«˜å“è³ªã‚·ãƒ³ã‚»ã‚µã‚¤ã‚¶ãƒ¼ã®è¨­å®š
                    this.synth = new Tone.PolySynth({
                        maxPolyphony: 24, // åŒæ™‚ç™ºéŸ³æ•°ã‚’24ã«å‰Šæ¸›ï¼ˆã‚ˆã‚Šå®‰å®šï¼‰
                        voice: Tone.Synth,
                        options: {
                            oscillator: {
                                type: "triangle", // ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªä¸‰è§’æ³¢
                                partialCount: 4   // å€éŸ³æˆåˆ†ã‚’åˆ¶é™ã—ã¦ã‚¯ãƒªãƒ¼ãƒ³ã«
                            },
                            envelope: {
                                attack: 0.008,    // ã‚ˆã‚Šè‡ªç„¶ãªç«‹ã¡ä¸ŠãŒã‚Šï¼ˆ8msï¼‰
                                decay: 0.12,      // é©åº¦ãªæ¸›è¡°
                                sustain: 0.6,     // æŒç¶šãƒ¬ãƒ™ãƒ«
                                release: 0.25     // è‡ªç„¶ãªä½™éŸ»ï¼ˆ250msï¼‰
                            },
                            // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¿½åŠ ï¼ˆé«˜å‘¨æ³¢ãƒã‚¤ã‚ºé™¤å»ï¼‰
                            filter: {
                                type: "lowpass", // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                                frequency: 3000, // 3kHzä»¥ä¸Šã‚’ã‚«ãƒƒãƒˆ
                                rolloff: -12     // ç·©ã‚„ã‹ãªã‚«ãƒƒãƒˆ
                            },
                            filterEnvelope: {
                                attack: 0.01,
                                decay: 0.1,
                                sustain: 0.8,
                                release: 0.2,
                                baseFrequency: 3000,
                                octaves: 0.5
                            }
                        }
                    });

                    // å®Œå…¨ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒã‚§ãƒ¼ãƒ³ã®æ§‹ç¯‰
                    // ã‚·ãƒ³ã‚» â†’ ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ â†’ ãƒã‚¹ã‚¿ãƒ¼ãƒœãƒªãƒ¥ãƒ¼ãƒ  â†’ ãƒªãƒŸãƒƒã‚¿ãƒ¼ â†’ å‡ºåŠ›
                    this.synth
                        .connect(this.compressor)
                        .connect(this.masterVolume)
                        .connect(this.limiter)
                        .toDestination();

                    // éŸ³è³ªçµ±è¨ˆæƒ…å ±ã®è¡¨ç¤º
                    if (this.debugMode.checked) {
                        console.log('ğŸµ è¶…é«˜å“è³ªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†');
                        console.log(`- ãƒãƒªãƒ•ã‚©ãƒ‹ãƒ¼: 24éŸ³`);
                        console.log(`- ãƒã‚¹ã‚¿ãƒ¼éŸ³é‡: -18dB`);
                        console.log(`- ãƒªãƒŸãƒƒã‚¿ãƒ¼: -1dB`);
                        console.log(`- æ³¢å½¢: ä¸‰è§’æ³¢ (4å€éŸ³)`);
                        console.log(`- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼: 3kHz ãƒ­ãƒ¼ãƒ‘ã‚¹`);
                        console.log(`- ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ: ${Tone.context.sampleRate}Hz`);
                    }

                    return true;
                } catch (error) {
                    console.error('é«˜å“è³ªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåˆæœŸåŒ–å¤±æ•—:', error);
                    // ç·Šæ€¥ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šæœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ã§å®‰å…¨ãªæ§‹æˆ
                    try {
                        this.masterVolume = new Tone.Volume(-24);
                        this.synth = new Tone.MonoSynth({
                            envelope: {
                                attack: 0.01,
                                release: 0.3
                            }
                        }).connect(this.masterVolume).toDestination();
                        console.log('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: è¶…å®‰å…¨ãƒ¢ãƒ¼ãƒ‰ã§åˆæœŸåŒ–');
                        return true;
                    } catch (fallbackError) {
                        console.error('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯åˆæœŸåŒ–ã‚‚å¤±æ•—:', fallbackError);
                        return false;
                    }
                }
            }

            // ã‚«ãƒ¡ãƒ©é–¢é€£
            async startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' }
                    });
                    this.video.srcObject = stream;
                    this.video.addEventListener('loadedmetadata', () => {
                        this.canvas.width = this.video.videoWidth;
                        this.canvas.height = this.video.videoHeight;
                        this.startScanning();
                    });

                    this.startBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    this.updateReceiverStatus('ã‚«ãƒ¡ãƒ©é–‹å§‹ - QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ä¸­...', 'success');
                } catch (error) {
                    this.updateReceiverStatus('ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
            }

            stopCamera() {
                this.isScanning = false;
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                    this.video.srcObject = null;
                }
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.updateReceiverStatus('ã‚«ãƒ¡ãƒ©åœæ­¢', 'info');
            }

            startScanning() {
                this.isScanning = true;
                this.scanFrame();
            }

            scanFrame() {
                if (!this.isScanning) return;

                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);

                if (code) {
                    this.processQRCode(code.data);
                }

                requestAnimationFrame(() => this.scanFrame());
            }

            // QRã‚³ãƒ¼ãƒ‰å‡¦ç†
            processQRCode(data) {
                try {
                    if (data.startsWith('M:')) {
                        const compressedArray = JSON.parse(data.substring(2));
                        const chunkData = this.decompressChunkData(compressedArray);

                        if (this.receivedChunks.has(chunkData.index)) {
                            return;
                        }

                        this.receivedChunks.set(chunkData.index, chunkData);
                        this.updateProgress();
                        this.createBigChunks();
                    }
                } catch (error) {
                    if (this.debugMode.checked) {
                        console.error('QRå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                    }
                }
            }

            decompressChunkData(arr) {
                return {
                    index: arr[0],
                    total: arr[1],
                    tempo: arr[2],
                    startTime: arr[3] / 1000,
                    endTime: arr[4] / 1000,
                    timeGroups: this.decompressTimeGroups(arr.slice(5))
                };
            }

            decompressTimeGroups(data) {
                const groups = [];
                let i = 0;

                while (i < data.length) {
                    const time = data[i] / 1000;
                    const noteCount = data[i + 1];
                    const notes = [];

                    for (let j = 0; j < noteCount; j++) {
                        const noteIndex = i + 2 + j * 3;
                        notes.push({
                            pitch: this.indexToNoteName(data[noteIndex]),
                            duration: data[noteIndex + 1] / 1000,
                            velocity: data[noteIndex + 2] / 127
                        });
                    }

                    groups.push({ time, notes });
                    i += 2 + noteCount * 3;
                }

                return groups;
            }

            indexToNoteName(index) {
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const octave = Math.floor(index / 12) - 1;
                const note = noteNames[index % 12];
                return note + octave;
            }

            // å¤§ãƒãƒ£ãƒ³ã‚¯ä½œæˆï¼ˆå°ã•ãªã‚°ãƒ«ãƒ¼ãƒ—ã‚‚å‡¦ç†ï¼‰
            createBigChunks() {
                const bigChunkSize = parseInt(this.bigChunkSize.value);
                const sortedIndices = Array.from(this.receivedChunks.keys()).sort((a, b) => a - b);

                // é€£ç¶šã™ã‚‹ãƒãƒ£ãƒ³ã‚¯ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
                let currentGroup = [];
                let lastIndex = -1;

                for (const index of sortedIndices) {
                    if (lastIndex === -1 || index === lastIndex + 1) {
                        currentGroup.push(index);
                        if (currentGroup.length >= bigChunkSize) {
                            this.createBigChunk(currentGroup);
                            currentGroup = [];
                        }
                    } else {
                        // é€£ç¶šã§ãªã„ãƒãƒ£ãƒ³ã‚¯ãŒæ¥ãŸå ´åˆã€ç¾åœ¨ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å‡¦ç†
                        if (currentGroup.length >= 1) { // 1ã¤ã§ã‚‚å¤§ãƒãƒ£ãƒ³ã‚¯ã¨ã—ã¦å‡¦ç†
                            this.createBigChunk(currentGroup);
                        }
                        currentGroup = [index];
                    }
                    lastIndex = index;
                }

                // æœ€å¾Œã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚‚å‡¦ç†ï¼ˆ1ã¤ã§ã‚‚å‡¦ç†ï¼‰
                if (currentGroup.length >= 1) {
                    this.createBigChunk(currentGroup);
                }
            }

            createBigChunk(chunkIndices) {
                const bigChunkId = chunkIndices.join('-');

                if (this.bigChunks.has(bigChunkId)) {
                    return;
                }

                const chunks = chunkIndices.map(index => this.receivedChunks.get(index));
                const bigChunk = {
                    id: bigChunkId,
                    chunkIndices: chunkIndices,
                    startTime: chunks[0].startTime,
                    endTime: chunks[chunks.length - 1].endTime,
                    chunks: chunks
                };

                this.bigChunks.set(bigChunkId, bigChunk);

                if (this.debugMode.checked) {
                    console.log(`å¤§ãƒãƒ£ãƒ³ã‚¯ä½œæˆ: ${bigChunkId}`);
                }

                // æ–°ã—ã„å¤§ãƒãƒ£ãƒ³ã‚¯ã®éŸ³ç¬¦ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
                this.addBigChunkToQueue(bigChunk);

                // æœ€åˆã®å¤§ãƒãƒ£ãƒ³ã‚¯ãŒå®Œæˆã—ãŸã‚‰å†ç”Ÿé–‹å§‹
                if (this.bigChunks.size === 1 && !this.isPlaying) {
                    setTimeout(() => this.startPlayback(), 100);
                }
            }

            // å¤§ãƒãƒ£ãƒ³ã‚¯ã®éŸ³ç¬¦ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ï¼ˆæ™‚é–“ãƒ™ãƒ¼ã‚¹é€²æ—å¯¾å¿œï¼‰
            addBigChunkToQueue(bigChunk) {
                const newNotes = [];

                bigChunk.chunks.forEach(chunk => {
                    chunk.timeGroups.forEach(timeGroup => {
                        timeGroup.notes.forEach(note => {
                            newNotes.push({
                                time: timeGroup.time,
                                pitch: note.pitch,
                                duration: note.duration,
                                velocity: note.velocity,
                                chunkId: bigChunk.id,
                                uniqueId: `${timeGroup.time}-${note.pitch}-${bigChunk.id}` // é‡è¤‡é˜²æ­¢ç”¨ID
                            });
                        });
                    });
                });

                // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼šæ—¢å­˜ã®ã‚­ãƒ¥ãƒ¼ã‚„å†ç”Ÿæ¸ˆã¿ãƒªã‚¹ãƒˆã«ãªã„éŸ³ç¬¦ã®ã¿è¿½åŠ 
                const existingIds = new Set([
                    ...this.noteQueue.map(n => n.uniqueId),
                    ...this.playedNotes.map(n => n.uniqueId)
                ]);

                const uniqueNewNotes = newNotes.filter(note => !existingIds.has(note.uniqueId));

                if (uniqueNewNotes.length > 0) {
                    // æ–°ã—ã„éŸ³ç¬¦ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
                    this.noteQueue.push(...uniqueNewNotes);
                    // æ™‚é–“é †ã§ã‚½ãƒ¼ãƒˆ
                    this.noteQueue.sort((a, b) => a.time - b.time);

                    // æ™‚é–“ãƒ™ãƒ¼ã‚¹é€²æ—æƒ…å ±ã‚’æ›´æ–°
                    this.updateDurationInfo();

                    if (this.debugMode.checked) {
                        console.log(`ã‚­ãƒ¥ãƒ¼ã«${uniqueNewNotes.length}éŸ³ç¬¦è¿½åŠ ï¼ˆé‡è¤‡é™¤å¤–ï¼š${newNotes.length - uniqueNewNotes.length}ï¼‰ã€‚å—ä¿¡æ™‚é–“: ${this.receivedMusicDuration.toFixed(1)}s / æ¨å®š${this.estimatedTotalDuration.toFixed(1)}s`);
                    }
                }
            }

            // æ¥½æ›²ã®æ™‚é–“æƒ…å ±ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
            updateDurationInfo() {
                // å—ä¿¡æ¸ˆã¿ãƒãƒ£ãƒ³ã‚¯ã‹ã‚‰å—ä¿¡æ¸ˆã¿éŸ³æ¥½æ™‚é–“ã‚’è¨ˆç®—
                if (this.receivedChunks.size > 0) {
                    const sortedChunks = Array.from(this.receivedChunks.values())
                        .sort((a, b) => a.index - b.index);

                    // é€£ç¶šã—ã¦å—ä¿¡ã§ãã¦ã„ã‚‹æœ€å¾Œã®ãƒãƒ£ãƒ³ã‚¯ã‚’è¦‹ã¤ã‘ã‚‹
                    let continuousEndTime = 0;
                    let expectedIndex = 0;

                    for (const chunk of sortedChunks) {
                        if (chunk.index === expectedIndex) {
                            continuousEndTime = chunk.endTime;
                            expectedIndex++;
                        } else {
                            break; // æ¬ ã‘ã¦ã„ã‚‹ãƒãƒ£ãƒ³ã‚¯ãŒã‚ã‚‹ã®ã§ã€ãã“ã§æ­¢ã‚ã‚‹
                        }
                    }

                    this.receivedMusicDuration = continuousEndTime;

                    // æ¥½æ›²å…¨ä½“ã®é•·ã•ã‚’æ¨å®šï¼ˆå—ä¿¡æ¸ˆã¿ãƒãƒ£ãƒ³ã‚¯ã‹ã‚‰ï¼‰
                    if (sortedChunks.length > 0) {
                        const totalChunks = sortedChunks[0].total;
                        const receivedChunks = this.receivedChunks.size;

                        if (receivedChunks > 0 && totalChunks > 0) {
                            // å¹³å‡ãƒãƒ£ãƒ³ã‚¯æ™‚é–“ã‹ã‚‰å…¨ä½“ã‚’æ¨å®š
                            const avgChunkDuration = continuousEndTime / expectedIndex;
                            this.estimatedTotalDuration = avgChunkDuration * totalChunks;
                        }
                    }
                }

                // ã‚­ãƒ¥ãƒ¼ã®æœ€å¾Œã®éŸ³ç¬¦ã‹ã‚‰å®Ÿéš›ã®æ¼”å¥æ™‚é–“ã‚’å–å¾—
                if (this.noteQueue.length > 0) {
                    const lastNote = this.noteQueue[this.noteQueue.length - 1];
                    this.totalMusicDuration = lastNote.time + (lastNote.duration || 0.5);
                }

                // å†ç”Ÿæ¸ˆã¿éŸ³ç¬¦ã‹ã‚‰ã‚‚ç¢ºèª
                if (this.playedNotes.length > 0) {
                    const lastPlayedNote = this.playedNotes[this.playedNotes.length - 1];
                    this.totalMusicDuration = Math.max(
                        this.totalMusicDuration,
                        lastPlayedNote.time + (lastPlayedNote.duration || 0.5)
                    );
                }
            }

            // ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°å†ç”Ÿé–‹å§‹
            async startPlayback() {
                if (this.isPlaying || this.noteQueue.length === 0) return;

                if (!this.synth) {
                    const success = await this.initializeAudio();
                    if (!success) {
                        this.updateReceiverStatus('ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåˆæœŸåŒ–å¤±æ•—', 'error');
                        return;
                    }
                }

                this.isPlaying = true;
                this.stopPlayBtn.disabled = false;
                this.playbackStartTime = Date.now();
                this.currentPlaybackTime = 0;

                this.updateReceiverStatus('å†ç”Ÿä¸­...', 'playing');
                this.startQueueProcessor();
            }

            startQueueProcessor() {
                this.playbackScheduler = setInterval(() => {
                    if (!this.isPlaying) return;

                    this.currentPlaybackTime = (Date.now() - this.playbackStartTime) / 1000;

                    // ãƒãƒƒãƒå‡¦ç†ï¼šä¸€åº¦ã«è¤‡æ•°ã®éŸ³ç¬¦ã‚’å‡¦ç†
                    // ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¿ã‚¤ãƒŸãƒ³ã‚°ç²¾åº¦ãŒå¤§å¹…ã«å‘ä¸Šã—ã¾ã™
                    const lookAheadTime = 0.2; // 200mså…ˆã¾ã§äº‹å‰ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
                    const tolerance = 0.1;     // è¨±å®¹ç¯„å›²ã‚’åºƒã‚ã«è¨­å®š
                    const maxNotesPerBatch = 50; // ä¸€åº¦ã«å‡¦ç†ã™ã‚‹éŸ³ç¬¦æ•°ã‚’åˆ¶é™

                    let notesInBatch = 0;
                    let notesPlayed = 0;

                    // ãƒãƒƒãƒå‡¦ç†ï¼šæ¡ä»¶ã«åˆã†éŸ³ç¬¦ã‚’ã¾ã¨ã‚ã¦å‡¦ç†
                    while (this.noteQueue.length > 0 && notesInBatch < maxNotesPerBatch) {
                        const nextNote = this.noteQueue[0];

                        // äº‹å‰ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç¯„å›²å†…ã®éŸ³ç¬¦ã‚’å‡¦ç†
                        if (nextNote.time <= this.currentPlaybackTime + lookAheadTime + tolerance) {
                            const noteToPlay = this.noteQueue.shift();
                            notesInBatch++;

                            // éŸ³ç¬¦ã‚’å†ç”Ÿã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’è¨ˆç®—
                            const playDelay = Math.max(0, noteToPlay.time - this.currentPlaybackTime);

                            // éŸ³é‡ã‚’å‹•çš„ã«èª¿æ•´ï¼ˆåŒæ™‚ç™ºéŸ³æ•°ã«å¿œã˜ã¦éŸ³é‡ã‚’ä¸‹ã’ã‚‹ï¼‰
                            const adjustedVelocity = this.calculateSafeVelocity(noteToPlay.velocity || 0.8);

                            try {
                                // Tone.jsã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°æ©Ÿèƒ½ã‚’ä½¿ç”¨
                                // ã“ã‚Œã«ã‚ˆã‚Šã€ã‚ˆã‚Šæ­£ç¢ºãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§éŸ³ç¬¦ã‚’å†ç”Ÿã§ãã¾ã™
                                this.synth.triggerAttackRelease(
                                    noteToPlay.pitch,
                                    noteToPlay.duration || 0.5,
                                    "+" + playDelay.toFixed(3), // ç›¸å¯¾çš„ãªæ™‚é–“æŒ‡å®š
                                    adjustedVelocity
                                );
                                notesPlayed++;

                                this.playedNotes.push({
                                    ...noteToPlay,
                                    actualPlayTime: this.currentPlaybackTime + playDelay,
                                    scheduledDelay: playDelay
                                });
                            } catch (error) {
                                if (this.debugMode.checked) {
                                    console.error('éŸ³ç¬¦å†ç”Ÿã‚¨ãƒ©ãƒ¼:', error, 'pitch:', noteToPlay.pitch);
                                }
                            }
                        } else {
                            // ã¾ã å‡¦ç†æ™‚åˆ»ã§ã¯ãªã„éŸ³ç¬¦ã«åˆ°é”
                            break;
                        }
                    }

                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã®è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°æ™‚ï¼‰
                    if (this.debugMode.checked && notesPlayed > 0) {
                        const activeVoices = this.synth.activeVoices ? this.synth.activeVoices : 'unknown';
                        console.log(`æ™‚åˆ» ${this.currentPlaybackTime.toFixed(3)}s: ${notesPlayed}éŸ³ç¬¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ¸ˆã¿, ã‚¢ã‚¯ãƒ†ã‚£ãƒ–éŸ³å£°: ${activeVoices}, ã‚­ãƒ¥ãƒ¼æ®‹ã‚Š: ${this.noteQueue.length}`);
                    }

                    // æ™‚é–“æƒ…å ±ã‚’æ›´æ–°ã—ã¦é€²æ—è¡¨ç¤ºã‚’æ­£ç¢ºã«ä¿ã¤
                    this.updateDurationInfo();
                    this.updateProgress();

                    // å†ç”Ÿå®Œäº†ãƒã‚§ãƒƒã‚¯
                    if (this.noteQueue.length === 0 && this.receivedChunks.size > 0) {
                        const totalChunks = Math.max(...Array.from(this.receivedChunks.values()).map(c => c.total));
                        if (this.receivedChunks.size >= totalChunks) {
                            setTimeout(() => {
                                if (this.noteQueue.length === 0) {
                                    this.updateReceiverStatus('å†ç”Ÿå®Œäº†', 'success');
                                }
                            }, 2000);
                        }
                    }

                }, 50); // 50msã«å¤‰æ›´ï¼ˆè² è·è»½æ¸›ã¨ã‚¿ã‚¤ãƒŸãƒ³ã‚°ç²¾åº¦ã®ãƒãƒ©ãƒ³ã‚¹ï¼‰
            }

            // å®‰å…¨ã§é«˜å“è³ªãªéŸ³é‡è¨ˆç®—ï¼šãƒã‚¤ã‚ºã‚’æ ¹æœ¬ã‹ã‚‰é˜²ã
            calculateSafeVelocity(originalVelocity) {
                // ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ è² è·ã‚’è€ƒæ…®ã—ãŸå‹•çš„éŸ³é‡èª¿æ•´
                const currentTime = Date.now();

                // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªéŸ³å£°æ•°ã®ç²¾å¯†ãªæ¨å®š
                // æœ€è¿‘å†ç”Ÿã•ã‚ŒãŸéŸ³ç¬¦ï¼ˆ500msä»¥å†…ï¼‰ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                const recentNotes = this.playedNotes.filter(note =>
                    currentTime - (note.actualPlayTime * 1000) < 500
                );

                const estimatedActiveVoices = Math.min(24, recentNotes.length);

                // å‘¨æ³¢æ•°ãƒã‚¹ã‚­ãƒ³ã‚°åŠ¹æœã‚’è€ƒæ…®ã—ãŸéŸ³é‡èª¿æ•´
                // äººé–“ã®è´è¦šã¯ã€ä¼¼ãŸå‘¨æ³¢æ•°ã®éŸ³ãŒè¤‡æ•°ã‚ã‚‹ã¨å€‹ã€…ã®éŸ³ã‚’åŒºåˆ¥ã—ã¥ã‚‰ããªã‚‹
                const voiceReductionFactor = this.calculateFrequencyMasking(estimatedActiveVoices);

                // éŸ³æ¥½çš„ãªè¡¨ç¾ã‚’ä¿ã¡ã¤ã¤å®‰å…¨ãªç¯„å›²ã«åˆ¶é™
                let adjustedVelocity = originalVelocity * voiceReductionFactor;

                // æ¥µç«¯ã«å°ã•ãªéŸ³é‡ã‚’é¿ã‘ã‚‹ï¼ˆãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢ã®å•é¡Œï¼‰
                adjustedVelocity = Math.max(0.02, adjustedVelocity);

                // ãƒ‡ã‚¸ã‚¿ãƒ«æ­ªã¿ã‚’çµ¶å¯¾ã«é˜²ããŸã‚ã®ä¸Šé™è¨­å®š
                adjustedVelocity = Math.min(0.4, adjustedVelocity);

                // å¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ã§ã®æœ€çµ‚èª¿æ•´ï¼ˆäººé–“ã®è´è¦šç‰¹æ€§ã«åˆã‚ã›ã‚‹ï¼‰
                return this.applyPsychoacousticCurve(adjustedVelocity);
            }

            // å‘¨æ³¢æ•°ãƒã‚¹ã‚­ãƒ³ã‚°åŠ¹æœã®è¨ˆç®—
            calculateFrequencyMasking(activeVoices) {
                if (activeVoices <= 1) return 1.0;

                // å‘¨æ³¢æ•°ãƒã‚¹ã‚­ãƒ³ã‚°ã®æ•°å­¦çš„ãƒ¢ãƒ‡ãƒ«
                // å¤šãã®éŸ³ãŒåŒæ™‚ã«é³´ã‚‹ã»ã©ã€å€‹ã€…ã®éŸ³é‡ã‚’ä¸‹ã’ã¦ã‚‚éŸ³æ¥½çš„è¡¨ç¾ã¯ç¶­æŒã•ã‚Œã‚‹
                const maskingFactor = 1.0 / Math.pow(activeVoices, 0.4);

                // æœ€å°å€¤ã‚’è¨­å®šï¼ˆå®Œå…¨ã«éŸ³é‡ã‚’ã‚¼ãƒ­ã«ã¯ã—ãªã„ï¼‰
                return Math.max(0.15, maskingFactor);
            }

            // å¿ƒç†éŸ³éŸ¿å­¦çš„éŸ³é‡ã‚«ãƒ¼ãƒ–ã®é©ç”¨
            applyPsychoacousticCurve(linearVolume) {
                // äººé–“ã®è´è¦šã¯å¯¾æ•°çš„ã«éŸ³é‡ã‚’æ„Ÿã˜ã‚‹ãŸã‚ã€
                // ç·šå½¢ã®éŸ³é‡å€¤ã‚’å¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ã«å¤‰æ›

                // Equal Loudness Contourï¼ˆç­‰ãƒ©ã‚¦ãƒ‰ãƒã‚¹æ›²ç·šï¼‰ã®ç°¡æ˜“ç‰ˆ
                const psychoacousticVolume = Math.pow(linearVolume, 0.7);

                return psychoacousticVolume;
            }

            // ã‚ˆã‚Šè‡ªç„¶ã§å®‰å…¨ãªéŸ³ç¬¦æŒç¶šæ™‚é–“ã®è¨ˆç®—
            calculateOptimalDuration(originalDuration, pitch, velocity) {
                // éŸ³ç¨‹ã¨éŸ³é‡ã«åŸºã¥ãè‡ªç„¶ãªæŒç¶šæ™‚é–“ã®è¨ˆç®—
                let optimalDuration = originalDuration || 0.5;

                // éŸ³ç¨‹ã«ã‚ˆã‚‹æŒç¶šæ™‚é–“èª¿æ•´
                const noteNumber = this.getPitchNumber(pitch);
                const middleC = 60;

                // ç‰©ç†çš„æ¥½å™¨ã®ç‰¹æ€§ã‚’æ¨¡å€£
                // ä½éŸ³ï¼šé•·ãéŸ¿ãã€é«˜éŸ³ï¼šçŸ­ãæ¸›è¡°ã™ã‚‹
                const pitchFactor = Math.exp(-(noteNumber - middleC) * 0.008);
                optimalDuration *= (0.7 + 0.6 * pitchFactor);

                // éŸ³é‡ã«ã‚ˆã‚‹æŒç¶šæ™‚é–“èª¿æ•´
                // å¤§ããªéŸ³ï¼šé•·ãéŸ¿ãã€å°ã•ãªéŸ³ï¼šçŸ­ãæ¸›è¡°ã™ã‚‹
                const velocityFactor = 0.5 + velocity * 0.8;
                optimalDuration *= velocityFactor;

                // å®Ÿç”¨çš„ãªç¯„å›²ã«åˆ¶é™
                optimalDuration = Math.max(0.08, Math.min(2.5, optimalDuration));

                return optimalDuration;
            }

            // éŸ³ç¨‹åã‹ã‚‰MIDIãƒãƒ¼ãƒˆç•ªå·ã‚’å–å¾—ï¼ˆã‚¨ãƒ©ãƒ¼å‡¦ç†å¼·åŒ–ç‰ˆï¼‰
            getPitchNumber(pitchName) {
                const noteMap = {
                    'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
                    'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
                    'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
                };

                try {
                    const match = pitchName.match(/([A-G][b#]?)(-?\d+)/);
                    if (!match) {
                        console.warn(`ä¸æ­£ãªéŸ³ç¨‹å: ${pitchName}, C4ã‚’ä½¿ç”¨`);
                        return 60; // C4ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                    }

                    const noteName = match[1];
                    const octave = parseInt(match[2]);

                    if (noteMap[noteName] === undefined) {
                        console.warn(`æœªçŸ¥ã®éŸ³å: ${noteName}, C4ã‚’ä½¿ç”¨`);
                        return 60;
                    }

                    const noteNumber = (octave + 1) * 12 + noteMap[noteName];

                    // MIDIè¦æ ¼ã®ç¯„å›²ãƒã‚§ãƒƒã‚¯ (0-127)
                    if (noteNumber < 0 || noteNumber > 127) {
                        console.warn(`MIDIç¯„å›²å¤–: ${noteNumber}, C4ã‚’ä½¿ç”¨`);
                        return 60;
                    }

                    return noteNumber;
                } catch (error) {
                    console.warn(`éŸ³ç¨‹è§£æã‚¨ãƒ©ãƒ¼: ${pitchName}`, error);
                    return 60; // å®‰å…¨ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                }
            }

            stopMidi() {
                this.isPlaying = false;
                this.stopPlayBtn.disabled = true;

                if (this.playbackScheduler) {
                    clearInterval(this.playbackScheduler);
                    this.playbackScheduler = null;
                }

                if (this.synth) {
                    this.synth.releaseAll();
                }

                // ã‚­ãƒ¥ãƒ¼ã¨å†ç”Ÿå±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.noteQueue.splice(0); // ã‚­ãƒ¥ãƒ¼ã‚’ã‚¯ãƒªã‚¢
                this.playedNotes.splice(0); // å†ç”Ÿå±¥æ­´ã‚‚ã‚¯ãƒªã‚¢
                this.updateReceiverStatus('åœæ­¢', 'info');
                this.updateProgress();
            }

            updateProgress() {
                // æ™‚é–“ãƒ™ãƒ¼ã‚¹é€²æ—ã‚·ã‚¹ãƒ†ãƒ ï¼šã‚ˆã‚Šç›´æ„Ÿçš„ã§ç†è§£ã—ã‚„ã™ã„é€²æ—è¡¨ç¤º

                // è–„ã„æ°´è‰²ã®ãƒãƒ¼ï¼šé€£ç¶šã—ã¦å—ä¿¡ã§ãã¦ã„ã‚‹éŸ³æ¥½æ™‚é–“ã®å‰²åˆ
                // ã€Œã“ã®æ™‚ç‚¹ã¾ã§é€”åˆ‡ã‚Œãšã«å—ä¿¡å®Œäº†ã—ã¦ã„ã‚‹ã€ã“ã¨ã‚’è¡¨ç¤º
                let receivedPercent = 0;
                if (this.estimatedTotalDuration > 0) {
                    receivedPercent = (this.receivedMusicDuration / this.estimatedTotalDuration) * 100;
                    // 100%ã‚’è¶…ãˆãªã„ã‚ˆã†ã«åˆ¶é™ï¼ˆæ¨å®šã®èª¤å·®ã‚’è€ƒæ…®ï¼‰
                    receivedPercent = Math.min(100, receivedPercent);
                }
                this.receivedProgress.style.width = `${receivedPercent}%`;

                // é’ã„ãƒãƒ¼ï¼šå®Ÿéš›ã®éŸ³æ¥½å†ç”Ÿé€²æ—
                // ã€Œæ¥½æ›²å…¨ä½“ã®ã†ã¡ã€ã©ã“ã¾ã§å†ç”Ÿã—ãŸã‹ã€ã‚’è¡¨ç¤º
                let playPercent = 0;
                if (this.isPlaying && this.totalMusicDuration > 0) {
                    playPercent = (this.currentPlaybackTime / this.totalMusicDuration) * 100;
                    // å—ä¿¡æ¸ˆã¿æ™‚é–“ã‚’è¶…ãˆã¦ã¯å†ç”Ÿã§ããªã„ã®ã§ã€ä¸Šé™ã‚’è¨­å®š
                    const maxPlayPercent = (this.receivedMusicDuration / this.totalMusicDuration) * 100;
                    playPercent = Math.min(playPercent, maxPlayPercent, 100);
                } else if (!this.isPlaying) {
                    // å†ç”ŸãŒåœæ­¢ã—ã¦ã„ã‚‹å ´åˆã¯0%ã«æˆ»ã™
                    playPercent = 0;
                }
                this.playProgress.style.width = `${playPercent}%`;

                // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®è¡¨ç¤ºï¼ˆé–‹ç™ºè€…ã«ã¨ã£ã¦æœ‰ç”¨ãªæƒ…å ±ï¼‰
                if (this.debugMode.checked) {
                    const debugInfo = {
                        received: `${this.receivedMusicDuration.toFixed(1)}s`,
                        estimated: `${this.estimatedTotalDuration.toFixed(1)}s`,
                        playing: `${this.currentPlaybackTime.toFixed(1)}s`,
                        total: `${this.totalMusicDuration.toFixed(1)}s`,
                        receivedPercent: `${receivedPercent.toFixed(1)}%`,
                        playPercent: `${playPercent.toFixed(1)}%`
                    };
                    console.log('é€²æ—çŠ¶æ³:', debugInfo);
                }
            }

            clearData() {
                this.receivedChunks.clear();
                this.bigChunks.clear();
                this.noteQueue.splice(0);
                this.playedNotes.splice(0);

                // æ™‚é–“ãƒ™ãƒ¼ã‚¹é€²æ—æƒ…å ±ã‚‚ãƒªã‚»ãƒƒãƒˆ
                this.totalMusicDuration = 0;
                this.receivedMusicDuration = 0;
                this.estimatedTotalDuration = 0;
                this.lastProcessedChunkIndex = -1;

                this.stopMidi();
                this.updateProgress();
                this.updateReceiverStatus('ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢', 'info');
            }

            // éŸ³ç¬¦ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼ï¼ˆä¸æ­£ãƒ‡ãƒ¼ã‚¿ã«ã‚ˆã‚‹ãƒã‚¤ã‚ºã‚’é˜²æ­¢ï¼‰
            validateNoteData(note) {
                if (!note || typeof note !== 'object') return false;

                // éŸ³ç¨‹ã®æ¤œè¨¼
                if (!note.pitch || typeof note.pitch !== 'string') return false;
                if (!/^[A-G][b#]?-?\d+$/.test(note.pitch)) return false;

                // æ™‚é–“ã®æ¤œè¨¼
                if (typeof note.time !== 'number' || note.time < 0) return false;

                // æŒç¶šæ™‚é–“ã®æ¤œè¨¼
                if (note.duration !== undefined) {
                    if (typeof note.duration !== 'number' || note.duration <= 0 || note.duration > 10) {
                        return false;
                    }
                }

                // éŸ³é‡ã®æ¤œè¨¼
                if (note.velocity !== undefined) {
                    if (typeof note.velocity !== 'number' || note.velocity < 0 || note.velocity > 1) {
                        return false;
                    }
                }

                return true;
            }

            // ã‚·ã‚¹ãƒ†ãƒ è² è·ç›£è¦–ï¼ˆé«˜è² è·æ™‚ã®ãƒã‚¤ã‚ºäºˆé˜²ï¼‰
            checkSystemLoad() {
                const currentTime = performance.now();

                // æœ€è¿‘ã®å‡¦ç†æ™‚é–“ã‚’è¨˜éŒ²
                if (!this.performanceMetrics) {
                    this.performanceMetrics = {
                        lastCheckTime: currentTime,
                        processingTimes: [],
                        maxSamples: 10
                    };
                }

                const timeDelta = currentTime - this.performanceMetrics.lastCheckTime;
                this.performanceMetrics.processingTimes.push(timeDelta);

                // ã‚µãƒ³ãƒ—ãƒ«æ•°ã‚’åˆ¶é™
                if (this.performanceMetrics.processingTimes.length > this.performanceMetrics.maxSamples) {
                    this.performanceMetrics.processingTimes.shift();
                }

                this.performanceMetrics.lastCheckTime = currentTime;

                // å¹³å‡å‡¦ç†æ™‚é–“ãŒé–¾å€¤ã‚’è¶…ãˆã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const avgProcessingTime = this.performanceMetrics.processingTimes.reduce((a, b) => a + b, 0) / this.performanceMetrics.processingTimes.length;

                // å‡¦ç†æ™‚é–“ãŒ60msï¼ˆç†æƒ³çš„ãª16.7msã®ç´„3.5å€ï¼‰ã‚’è¶…ãˆãŸã‚‰é«˜è² è·ã¨ã¿ãªã™
                return avgProcessingTime > 60;
            }

            // ã‚¨ãƒ©ãƒ¼å›å¾©æ©Ÿèƒ½ä»˜ãéŸ³ç¬¦å†ç”Ÿ
            async playNoteWithErrorRecovery(pitch, duration, scheduledTime, velocity) {
                const maxRetries = 2;
                let attempt = 0;

                while (attempt < maxRetries) {
                    try {
                        // Tone.jsã§ã®å®‰å…¨ãªéŸ³ç¬¦å†ç”Ÿ
                        this.synth.triggerAttackRelease(
                            pitch,
                            duration,
                            scheduledTime,
                            velocity
                        );

                        // æˆåŠŸã—ãŸã‚‰å³åº§ã«ãƒªã‚¿ãƒ¼ãƒ³
                        return;

                    } catch (error) {
                        attempt++;

                        if (this.debugMode.checked) {
                            console.warn(`éŸ³ç¬¦å†ç”Ÿè©¦è¡Œ ${attempt}/${maxRetries} å¤±æ•—:`, {
                                pitch,
                                duration,
                                scheduledTime,
                                velocity,
                                error: error.message
                            });
                        }

                        if (attempt >= maxRetries) {
                            // æœ€çµ‚çš„ã«å¤±æ•—ã—ãŸå ´åˆã®ç·Šæ€¥å¯¾å¿œ
                            try {
                                // ã‚ˆã‚Šå®‰å…¨ãªè¨­å®šã§ãƒªãƒˆãƒ©ã‚¤
                                this.synth.triggerAttackRelease(
                                    'C4', // å®‰å…¨ãªéŸ³ç¨‹
                                    0.1,  // çŸ­ã„æŒç¶šæ™‚é–“
                                    '+0.01', // å³åº§ã«å†ç”Ÿ
                                    0.1   // å°ã•ãªéŸ³é‡
                                );

                                if (this.debugMode.checked) {
                                    console.log('ç·Šæ€¥ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯éŸ³ç¬¦ã§ä»£æ›¿å†ç”Ÿ');
                                }
                            } catch (fallbackError) {
                                if (this.debugMode.checked) {
                                    console.error('å®Œå…¨ãªéŸ³ç¬¦å†ç”Ÿå¤±æ•—:', fallbackError);
                                }
                            }
                        } else {
                            // çŸ­æ™‚é–“å¾…æ©Ÿã—ã¦ãƒªãƒˆãƒ©ã‚¤
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                }
            }

            // ã‚·ã‚¹ãƒ†ãƒ è² è·ãƒ¬ãƒ™ãƒ«ã®å–å¾—
            getSystemLoadLevel() {
                if (!this.performanceMetrics || this.performanceMetrics.processingTimes.length === 0) {
                    return 'unknown';
                }

                const avgTime = this.performanceMetrics.processingTimes.reduce((a, b) => a + b, 0) / this.performanceMetrics.processingTimes.length;

                if (avgTime < 20) return 'low';
                if (avgTime < 40) return 'medium';
                if (avgTime < 60) return 'high';
                return 'critical';
            }

            updateReceiverStatus(message, type) {
                this.receiverStatus.textContent = message;
                this.receiverStatus.className = `status ${type}`;
            }

            // é€ä¿¡å´ãƒ¡ã‚½ãƒƒãƒ‰
            async loadMidiFile() {
                const file = this.midiFile.files[0];
                if (!file) {
                    this.updateSenderStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                    return;
                }

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.originalMidi = new Midi(arrayBuffer);
                    this.generateBtn.disabled = false;
                    this.updateSenderStatus('MIDIèª­ã¿è¾¼ã¿å®Œäº†', 'success');
                } catch (error) {
                    this.updateSenderStatus('èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
            }

            generateQRCodes() {
                if (!this.originalMidi) return;

                const chunkNoteCount = parseInt(this.chunkNoteCount.value);
                this.qrChunks = [];

                const chunks = this.splitMidiByNoteCount(this.originalMidi, chunkNoteCount);

                chunks.forEach((chunk, index) => {
                    const compressedData = this.compressChunkData(chunk, index, chunks.length);
                    const qrData = 'M:' + JSON.stringify(compressedData);
                    this.qrChunks.push(qrData);
                });

                this.currentChunkIndex = 0;
                this.flashBtn.disabled = false;
                this.updateSenderStatus(`${this.qrChunks.length}å€‹ã®QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆå®Œäº†`, 'success');
                this.updateProgressDisplay();
                this.updateDataSizeDisplay();

                if (this.qrChunks.length > 0) {
                    this.displayQRCode(this.qrChunks[0]);
                }
            }

            compressChunkData(chunk, index, total) {
                const compressed = [
                    index,
                    total,
                    Math.round(chunk.tempo || 120),
                    Math.round(chunk.startTime * 1000),
                    Math.round(chunk.endTime * 1000),
                ];

                chunk.timeGroups.forEach(timeGroup => {
                    compressed.push(Math.round(timeGroup.time * 1000));
                    compressed.push(timeGroup.notes.length);

                    timeGroup.notes.forEach(note => {
                        compressed.push(this.noteNameToIndex(note.pitch));
                        compressed.push(Math.round(note.duration * 1000));
                        compressed.push(Math.round(note.velocity * 127));
                    });
                });

                return compressed;
            }

            noteNameToIndex(noteName) {
                const noteMap = { 'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11 };
                const match = noteName.match(/([A-G]#?)(-?\d+)/);
                if (!match) return 60;

                const note = match[1];
                const octave = parseInt(match[2]);
                return (octave + 1) * 12 + noteMap[note];
            }

            splitMidiByNoteCount(midi, maxNotesPerChunk) {
                const allNotes = [];
                midi.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        allNotes.push({
                            pitch: note.name,
                            time: note.time,
                            duration: note.duration,
                            velocity: note.velocity || 0.8
                        });
                    });
                });

                allNotes.sort((a, b) => a.time - b.time);

                const timeGroups = [];
                let currentTime = null;
                let currentGroup = null;
                const timeThreshold = 0.01;

                allNotes.forEach(note => {
                    const roundedTime = Math.round(note.time * 1000) / 1000;

                    if (currentTime === null || Math.abs(roundedTime - currentTime) > timeThreshold) {
                        if (currentGroup) {
                            timeGroups.push(currentGroup);
                        }
                        currentTime = roundedTime;
                        currentGroup = {
                            time: roundedTime,
                            notes: []
                        };
                    }

                    currentGroup.notes.push({
                        pitch: note.pitch,
                        duration: note.duration,
                        velocity: note.velocity
                    });
                });

                if (currentGroup) {
                    timeGroups.push(currentGroup);
                }

                const chunks = [];
                let currentChunk = null;
                let noteCount = 0;

                timeGroups.forEach(timeGroup => {
                    if (!currentChunk || noteCount + timeGroup.notes.length > maxNotesPerChunk) {
                        if (currentChunk) {
                            const lastGroup = currentChunk.timeGroups[currentChunk.timeGroups.length - 1];
                            const maxDuration = Math.max(...lastGroup.notes.map(n => n.duration || 0.5));
                            currentChunk.endTime = lastGroup.time + maxDuration;
                            chunks.push(currentChunk);
                        }

                        currentChunk = {
                            timeGroups: [],
                            startTime: timeGroup.time,
                            endTime: 0,
                            tempo: midi.header.tempos.length > 0 ? midi.header.tempos[0].bpm : 120
                        };
                        noteCount = 0;
                    }

                    currentChunk.timeGroups.push(timeGroup);
                    noteCount += timeGroup.notes.length;
                });

                if (currentChunk) {
                    const lastGroup = currentChunk.timeGroups[currentChunk.timeGroups.length - 1];
                    const maxDuration = Math.max(...lastGroup.notes.map(n => n.duration || 0.5));
                    currentChunk.endTime = lastGroup.time + maxDuration;
                    chunks.push(currentChunk);
                }

                return chunks;
            }

            displayQRCode(data) {
                try {
                    const qr = new QRious({
                        element: this.qrCanvas,
                        value: data,
                        size: 350,
                        background: 'white',
                        foreground: 'black',
                        level: 'M'
                    });
                } catch (error) {
                    this.updateSenderStatus('QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
            }

            startFlashing() {
                if (this.qrChunks.length === 0) return;

                const fps = parseInt(this.flashFPS.value);
                const interval = 1000 / fps;

                this.flashInterval = setInterval(() => {
                    this.displayQRCode(this.qrChunks[this.currentChunkIndex]);
                    this.currentChunkIndex = (this.currentChunkIndex + 1) % this.qrChunks.length;
                    this.updateProgressDisplay();
                }, interval);

                this.flashBtn.disabled = true;
                this.stopFlashBtn.disabled = false;
                this.updateSenderStatus(`${fps}FPSã§é€ä¿¡ä¸­...`, 'success');
            }

            stopFlashing() {
                if (this.flashInterval) {
                    clearInterval(this.flashInterval);
                    this.flashInterval = null;
                }
                this.flashBtn.disabled = false;
                this.stopFlashBtn.disabled = true;
                this.updateSenderStatus('é€ä¿¡åœæ­¢', 'info');
            }

            updateProgressDisplay() {
                this.progressDisplay.textContent = `${this.currentChunkIndex + 1} / ${this.qrChunks.length}`;
            }

            updateDataSizeDisplay() {
                if (this.qrChunks.length === 0) {
                    this.dataSizeDisplay.textContent = '0B';
                    return;
                }

                const totalSize = this.qrChunks.reduce((sum, qr) => sum + qr.length, 0);
                const avgSize = Math.round(totalSize / this.qrChunks.length);

                this.dataSizeDisplay.textContent = `å¹³å‡${avgSize}B`;
            }

            updateSenderStatus(message, type) {
                this.senderStatus.textContent = message;
                this.senderStatus.className = `status ${type}`;
            }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            new MIDIQRStreaming();
        });
    </script>
</body>

</html>