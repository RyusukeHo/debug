<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ€é©åŒ–4è‰²QRã‚³ãƒ¼ãƒ‰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsQR/1.4.0/jsQR.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
        }
        
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab.active {
            border-bottom-color: #007bff;
            color: #007bff;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        #video {
            width: 100%;
            max-width: 400px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        
        #canvas, #tempCanvas {
            display: none;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        input, textarea, select {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            margin: 10px 0;
        }
        
        textarea {
            width: 100%;
            height: 120px;
            resize: vertical;
            box-sizing: border-box;
        }
        
        #input-text {
            width: 100%;
            box-sizing: border-box;
        }
        
        #result {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            min-height: 50px;
            border-left: 4px solid #28a745;
        }
        
        #qr-output {
            margin-top: 20px;
            text-align: center;
        }
        
        .qr-container {
            display: inline-block;
            margin: 15px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            vertical-align: top;
        }
        
        .qr-grid {
            border: 2px solid #333;
            display: inline-block;
            margin: 10px 0;
        }
        
        .qr-row {
            display: flex;
            line-height: 0;
        }
        
        .qr-cell {
            width: 4px;
            height: 4px;
            display: inline-block;
        }
        
        .color-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .color-box {
            width: 24px;
            height: 24px;
            border: 2px solid #333;
            border-radius: 4px;
        }
        
        .settings {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }
        
        .settings label {
            display: block;
            margin: 10px 0 5px 0;
            font-weight: bold;
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .stats {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }
        
        .efficiency-badge {
            background: #28a745;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .size-badge {
            background: #dc3545;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .comparison {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .comparison h4 {
            margin: 0 0 10px 0;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ æœ€é©åŒ–4è‰²QRã‚³ãƒ¼ãƒ‰ (çœŸã®åŠ¹ç‡åŒ–å®Ÿè£…)</h1>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('reader')">ğŸ“¸ èª­ã¿å–ã‚Š</button>
            <button class="tab" onclick="switchTab('generator')">ğŸ¨ ç”Ÿæˆ</button>
        </div>
        
        <!-- èª­ã¿å–ã‚Šã‚¿ãƒ– -->
        <div id="reader" class="tab-content active">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
            <canvas id="tempCanvas"></canvas>
            
            <div class="controls">
                <button onclick="startCamera()">ğŸ“· ã‚«ãƒ¡ãƒ©é–‹å§‹</button>
                <button onclick="toggleScanning()" id="scanButton">ğŸ” ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹</button>
                <button onclick="stopCamera()">â¹ï¸ ã‚«ãƒ¡ãƒ©åœæ­¢</button>
            </div>
            
            <div id="result">èª­ã¿å–ã‚ŠçµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</div>
        </div>
        
        <!-- ç”Ÿæˆã‚¿ãƒ– -->
        <div id="generator" class="tab-content">
            <div class="settings">
                <label for="error-level">Reed-Solomon ã‚¨ãƒ©ãƒ¼è¨‚æ­£ãƒ¬ãƒ™ãƒ«:</label>
                <select id="error-level">
                    <option value="10">ä½ (10%)</option>
                    <option value="20" selected>ä¸­ (20%)</option>
                    <option value="30">é«˜ (30%)</option>
                    <option value="40">æœ€é«˜ (40%)</option>
                </select>
                
                <label for="cell-size">ã‚»ãƒ«ã‚µã‚¤ã‚º:</label>
                <select id="cell-size">
                    <option value="3">å° (3px)</option>
                    <option value="5" selected>ä¸­ (5px)</option>
                    <option value="7">å¤§ (7px)</option>
                    <option value="10">ç‰¹å¤§ (10px)</option>
                </select>
                
                <label for="optimization">æœ€é©åŒ–ãƒ¢ãƒ¼ãƒ‰:</label>
                <select id="optimization">
                    <option value="size" selected>ã‚µã‚¤ã‚ºæœ€å°åŒ–</option>
                    <option value="reliability">ä¿¡é ¼æ€§é‡è¦–</option>
                    <option value="balanced">ãƒãƒ©ãƒ³ã‚¹</option>
                </select>
            </div>
            
            <textarea id="input-text" placeholder="ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."></textarea>
            
            <div class="controls">
                <button onclick="generateOptimizedColorQR()">ğŸš€ æœ€é©åŒ–4è‰²QRç”Ÿæˆ</button>
                <button onclick="generateStandardQR()">âš« æ¨™æº–QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ</button>
                <button onclick="clearOutput()">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
            </div>
            
            <div class="color-legend">
                <div class="color-item">
                    <div class="color-box" style="background: #000"></div>
                    é»’ (00)
                </div>
                <div class="color-item">
                    <div class="color-box" style="background: #fff; border-color: #000"></div>
                    ç™½ (01)
                </div>
                <div class="color-item">
                    <div class="color-box" style="background: #00f"></div>
                    é’ (10)
                </div>
                <div class="color-item">
                    <div class="color-box" style="background: #0f0"></div>
                    ç·‘ (11)
                </div>
            </div>
            
            <div id="qr-output"></div>
        </div>
    </div>

    <script>
        // 4è‰²å®šç¾©
        const colors = [
            [0, 0, 0],         // é»’ (00)
            [255, 255, 255],   // ç™½ (01)
            [0, 0, 255],       // é’ (10)
            [0, 255, 0]        // ç·‘ (11)
        ];
        
        let stream = null;
        let scanning = false;
        let scanInterval = null;
        
        // Reed-Solomon ã‚¨ãƒ©ãƒ¼è¨‚æ­£ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
        class ReedSolomon {
            constructor(errorCorrectionRate) {
                this.errorRate = errorCorrectionRate / 100;
            }
            
            encode(data) {
                const dataBytes = data.length;
                const errorBytes = Math.ceil(dataBytes * this.errorRate / (1 - this.errorRate));
                
                // å®Ÿéš›ã®RSç¬¦å·ã®ä»£ã‚ã‚Šã«ç°¡æ˜“ãƒã‚§ãƒƒã‚¯ã‚µãƒ ï¼ˆå®Ÿè£…ç°¡ç•¥åŒ–ï¼‰
                let checksum = 0;
                for (let i = 0; i < data.length; i++) {
                    checksum ^= data.charCodeAt(i);
                    checksum = ((checksum << 1) | (checksum >> 7)) & 0xFF;
                }
                
                const errorCorrection = [];
                for (let i = 0; i < errorBytes; i++) {
                    errorCorrection.push(checksum ^ i);
                }
                
                return {
                    data: data,
                    errorCorrection: errorCorrection,
                    totalBytes: dataBytes + errorBytes
                };
            }
            
            decode(encodedData, errorCorrection) {
                // ç°¡æ˜“ã‚¨ãƒ©ãƒ¼æ¤œå‡ºï¼ˆå®Ÿè£…ç°¡ç•¥åŒ–ï¼‰
                try {
                    return encodedData;
                } catch (e) {
                    throw new Error('ã‚¨ãƒ©ãƒ¼è¨‚æ­£ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }
        }
        
        // æœ€é©ãªQRã‚µã‚¤ã‚ºè¨ˆç®—
        function calculateOptimalSize(dataLength, errorCorrectionRate, optimization) {
            const totalBits = dataLength * 8;
            const errorBits = Math.ceil(totalBits * errorCorrectionRate / 100);
            const totalDataBits = totalBits + errorBits;
            
            // 4è‰²ãªã®ã§2ãƒ“ãƒƒãƒˆ/ã‚»ãƒ«
            const dataCells = Math.ceil(totalDataBits / 2);
            
            // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰è¨ˆç®—
            let size = 21; // æœ€å°ã‚µã‚¤ã‚º
            let availableCells;
            
            do {
                // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ç­‰ã‚’é™¤ã„ãŸåˆ©ç”¨å¯èƒ½ã‚»ãƒ«æ•°
                const positionPatterns = 3 * 8 * 8; // 3ã¤ã®8x8ãƒ‘ã‚¿ãƒ¼ãƒ³
                const timingPatterns = (size - 16) * 2; // ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³
                const separators = 3 * 8 * 3; // åˆ†é›¢ãƒ‘ã‚¿ãƒ¼ãƒ³
                const formatInfo = 31; // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæƒ…å ±
                
                availableCells = size * size - positionPatterns - timingPatterns - separators - formatInfo;
                
                if (availableCells < dataCells) {
                    size += 4; // QRã‚³ãƒ¼ãƒ‰ã¯4ã®å€æ•°+1ã§å¢—åŠ 
                }
            } while (availableCells < dataCells && size < 200);
            
            // æœ€é©åŒ–ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ãŸèª¿æ•´
            switch (optimization) {
                case 'size':
                    // ã‚µã‚¤ã‚ºæœ€å°åŒ–ï¼šãã‚Šãã‚Šã¾ã§å‰Šã‚‹
                    break;
                case 'reliability':
                    // ä¿¡é ¼æ€§é‡è¦–ï¼š20%ä½™è£•ã‚’æŒãŸã›ã‚‹
                    size += 4;
                    break;
                case 'balanced':
                    // ãƒãƒ©ãƒ³ã‚¹ï¼š10%ä½™è£•
                    if (availableCells / dataCells < 1.1) {
                        size += 4;
                    }
                    break;
            }
            
            return Math.min(size, 177); // QRã‚³ãƒ¼ãƒ‰ã®æœ€å¤§ã‚µã‚¤ã‚ºåˆ¶é™
        }
        
        // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'reader') {
                stopScanning();
            }
        }
        
        // ã‚«ãƒ¡ãƒ©é–‹å§‹
        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                
                const video = document.getElementById('video');
                video.srcObject = stream;
                
                showStatus('ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¾ã—ãŸ', 'success');
            } catch (error) {
                showStatus('ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—: ' + error.message, 'error');
            }
        }
        
        // ã‚«ãƒ¡ãƒ©åœæ­¢
        function stopCamera() {
            stopScanning();
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                document.getElementById('video').srcObject = null;
                showStatus('ã‚«ãƒ¡ãƒ©ã‚’åœæ­¢ã—ã¾ã—ãŸ', 'info');
            }
        }
        
        // ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹/åœæ­¢
        function toggleScanning() {
            if (scanning) {
                stopScanning();
            } else {
                startScanning();
            }
        }
        
        function startScanning() {
            const video = document.getElementById('video');
            if (!video.videoWidth) {
                showStatus('ã‚«ãƒ¡ãƒ©ãŒé–‹å§‹ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }
            
            scanning = true;
            document.getElementById('scanButton').textContent = 'â¸ï¸ ã‚¹ã‚­ãƒ£ãƒ³åœæ­¢';
            
            scanInterval = setInterval(() => {
                analyzeFrame();
            }, 150);
            
            showStatus('ã‚¹ã‚­ãƒ£ãƒ³ã‚’é–‹å§‹ã—ã¾ã—ãŸ', 'info');
        }
        
        function stopScanning() {
            scanning = false;
            if (scanInterval) {
                clearInterval(scanInterval);
                scanInterval = null;
            }
            document.getElementById('scanButton').textContent = 'ğŸ” ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹';
        }
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ è§£æï¼ˆãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ–¹å¼ï¼‰
        function analyzeFrame() {
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // æ¨™æº–QRã§ä½ç½®æ¤œå‡ºï¼ˆjsQRã®ä½ç½®æ¤œå‡ºæ©Ÿèƒ½ã‚’æ´»ç”¨ï¼‰
            const standardQR = jsQR(imageData.data, imageData.width, imageData.height);
            
            if (standardQR) {
                // ä½ç½®æƒ…å ±ã¯æ¨™æº–QRã‹ã‚‰å–å¾—ã€ãƒ‡ãƒ¼ã‚¿èª­ã¿å–ã‚Šã¯4è‰²å¯¾å¿œ
                analyzeHybridColorQR(canvas, ctx, standardQR);
                stopScanning();
            }
        }
        
        // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰4è‰²QRè§£æï¼ˆä½ç½®æ¤œå‡ºã¯æ¨™æº–ã€ãƒ‡ãƒ¼ã‚¿èª­ã¿å–ã‚Šã¯4è‰²ï¼‰
        function analyzeHybridColorQR(canvas, ctx, qrResult) {
            try {
                const corners = [
                    qrResult.location.topLeftCorner,
                    qrResult.location.topRightCorner,
                    qrResult.location.bottomRightCorner,
                    qrResult.location.bottomLeftCorner
                ];
                
                // QRã‚³ãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚ºæ¨å®š
                const width = Math.sqrt(
                    Math.pow(corners[1].x - corners[0].x, 2) + 
                    Math.pow(corners[1].y - corners[0].y, 2)
                );
                
                const moduleSize = width / 21; // æ¨™æº–çš„ãª21x21ã¨ã—ã¦ä»®å®š
                const gridSize = Math.round(width / moduleSize);
                
                // é€è¦–å¤‰æ›ã§QRã‚³ãƒ¼ãƒ‰ã‚’æ­£è¦åŒ–
                const normalizedQR = extractNormalizedQR(canvas, ctx, corners, gridSize);
                
                // æ¨™æº–QRã¨ã—ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰
                const standardData = qrResult.data;
                
                // 4è‰²QRã¨ã—ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰
                const colorData = analyzeColorGrid(normalizedQR, gridSize);
                const colorDecodedText = decodeHybridColorQR(colorData, gridSize);
                
                // çµæœæ¯”è¼ƒè¡¨ç¤º
                displayHybridResult({
                    standard: {
                        data: standardData,
                        method: 'æ¨™æº–QR (jsQR)'
                    },
                    color: {
                        data: colorDecodedText,
                        method: '4è‰²ãƒ‡ãƒ¼ã‚¿èª­ã¿å–ã‚Š',
                        confidence: calculateColorConfidence(colorData),
                        colorStats: getColorStats(colorData)
                    },
                    gridSize: gridSize,
                    moduleSize: moduleSize.toFixed(2),
                    corners: corners
                });
                
            } catch (error) {
                displayHybridResult({
                    standard: { data: qrResult.data, method: 'æ¨™æº–QR (jsQR)' },
                    color: { data: null, error: error.message },
                    gridSize: null
                });
            }
        }
        
        // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰4è‰²QRãƒ‡ã‚³ãƒ¼ãƒ‰ï¼ˆä½ç½®æ¤œå‡ºã¯æ¨™æº–QRã€ãƒ‡ãƒ¼ã‚¿ã¯4è‰²ï¼‰
        function decodeHybridColorQR(colorGrid, gridSize) {
            if (!colorGrid || colorGrid.length === 0) return null;
            
            let binaryString = '';
            
            // ãƒ‡ãƒ¼ã‚¿é ˜åŸŸã‚’ç‰¹å®šï¼ˆæ¨™æº–QRã®æ§‹é€ ã‚’å‚è€ƒã«ã—ã¤ã¤4è‰²ã§èª­ã¿å–ã‚Šï¼‰
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    // æ¨™æº–QRã®æ©Ÿèƒ½ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¿ã‘ã‚‹
                    if (isStandardQRFunctionalArea(x, y, gridSize)) {
                        continue; // æ©Ÿèƒ½ãƒ‘ã‚¿ãƒ¼ãƒ³é ˜åŸŸã¯ã‚¹ã‚­ãƒƒãƒ—
                    }
                    
                    // ãƒ‡ãƒ¼ã‚¿é ˜åŸŸã®ã¿4è‰²ã¨ã—ã¦è§£é‡ˆ
                    if (y < colorGrid.length && x < colorGrid[y].length) {
                        const colorIndex = colorGrid[y][x];
                        // 4è‰²ã‚’2ãƒ“ãƒƒãƒˆã«å¤‰æ›
                        binaryString += colorIndex.toString(2).padStart(2, '0');
                    }
                }
            }
            
            // ãƒã‚¤ãƒŠãƒªã‚’æ–‡å­—åˆ—ã«å¤‰æ›
            let resultText = '';
            for (let i = 0; i < binaryString.length; i += 8) {
                const byte = binaryString.substr(i, 8);
                if (byte.length === 8) {
                    const charCode = parseInt(byte, 2);
                    if (charCode === 0) {
                        break; // çµ‚ç«¯ãƒãƒ¼ã‚«ãƒ¼
                    }
                    if (charCode >= 32 && charCode <= 126) {
                        resultText += String.fromCharCode(charCode);
                    }
                }
            }
            
            return resultText.length > 0 ? resultText : null;
        }
        
        // æ¨™æº–QRã®æ©Ÿèƒ½é ˜åŸŸåˆ¤å®š
        function isStandardQRFunctionalArea(x, y, size) {
            // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³
            if ((x < 9 && y < 9) || 
                (x >= size - 8 && y < 9) || 
                (x < 9 && y >= size - 8)) {
                return true;
            }
            
            // ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³
            if (x === 6 || y === 6) {
                return true;
            }
            
            // ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç°¡æ˜“åˆ¤å®šï¼‰
            if (size >= 25) {
                const centers = getAlignmentPatternCenters(size);
                for (let center of centers) {
                    if (Math.abs(x - center.x) <= 2 && Math.abs(y - center.y) <= 2) {
                        return true;
                    }
                }
            }
            
            // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæƒ…å ±
            if ((x < 9 && y === 8) || (x === 8 && y < 9) ||
                (x === 8 && y >= size - 8) || (x >= size - 8 && y === 8)) {
                return true;
            }
            
            return false;
        }
        
        // ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¸­å¿ƒåº§æ¨™å–å¾—
        function getAlignmentPatternCenters(size) {
            // ç°¡æ˜“ç‰ˆï¼šå®Ÿéš›ã¯ã‚‚ã£ã¨è¤‡é›‘ãªè¨ˆç®—ãŒå¿…è¦
            if (size < 25) return [];
            
            const centers = [];
            if (size >= 25 && size < 45) {
                centers.push({ x: Math.floor(size/2), y: Math.floor(size/2) });
            }
            return centers;
        }
        
        // 4è‰²ã®ä¿¡é ¼åº¦è¨ˆç®—
        function calculateColorConfidence(colorGrid) {
            if (!colorGrid || colorGrid.length === 0) return 0;
            
            let validColors = 0;
            let totalCells = 0;
            let colorCounts = [0, 0, 0, 0];
            
            for (let row of colorGrid) {
                for (let cell of row) {
                    if (cell >= 0 && cell <= 3) {
                        validColors++;
                        colorCounts[cell]++;
                    }
                    totalCells++;
                }
            }
            
            // 4è‰²ã™ã¹ã¦ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const colorsUsed = colorCounts.filter(count => count > 0).length;
            const colorDiversity = colorsUsed / 4;
            
            const validRatio = totalCells > 0 ? validColors / totalCells : 0;
            
            return Math.floor((validRatio * 0.7 + colorDiversity * 0.3) * 100);
        }
        
        // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰çµæœè¡¨ç¤º
        function displayHybridResult(result) {
            const resultDiv = document.getElementById('result');
            let html = '<h3>ğŸ”„ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰è§£æçµæœ</h3>';
            
            // æ¨™æº–QRçµæœ
            if (result.standard && result.standard.data) {
                html += `
                    <div style="background: #e7f3ff; padding: 15px; border-radius: 6px; margin: 10px 0; border-left: 4px solid #2196F3;">
                        <h4>ğŸ“‹ æ¨™æº–QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Š</h4>
                        <p><strong>ãƒ‡ãƒ¼ã‚¿:</strong></p>
                        <div style="background: white; padding: 10px; border-radius: 4px; word-break: break-all; font-family: monospace;">
                            ${result.standard.data}
                        </div>
                        <small>æ¤œå‡ºæ–¹æ³•: ${result.standard.method}</small>
                    </div>
                `;
            }
            
            // 4è‰²QRçµæœ
            if (result.color) {
                if (result.color.data) {
                    html += `
                        <div style="background: #e8f5e8; padding: 15px; border-radius: 6px; margin: 10px 0; border-left: 4px solid #4CAF50;">
                            <h4>ğŸ¨ 4è‰²ãƒ‡ãƒ¼ã‚¿èª­ã¿å–ã‚Š</h4>
                            <p><strong>ãƒ‡ãƒ¼ã‚¿:</strong></p>
                            <div style="background: white; padding: 10px; border-radius: 4px; word-break: break-all; font-family: monospace;">
                                ${result.color.data}
                            </div>
                            <small>
                                æ¤œå‡ºæ–¹æ³•: ${result.color.method} | 
                                ä¿¡é ¼åº¦: ${result.color.confidence}%
                            </small>
                        </div>
                    `;
                    
                    // è‰²ä½¿ç”¨çµ±è¨ˆ
                    if (result.color.colorStats) {
                        html += `
                            <div style="background: #fff3e0; padding: 15px; border-radius: 6px; margin: 10px 0;">
                                <h5>ğŸ“Š è‰²ä½¿ç”¨çµ±è¨ˆ</h5>
                                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                        `;
                        
                        result.color.colorStats.forEach((stat, i) => {
                            const colorStyle = `background: rgb(${colors[i][0]}, ${colors[i][1]}, ${colors[i][2]}); color: ${i === 1 ? 'black' : 'white'};`;
                            html += `
                                <div style="padding: 5px 10px; border-radius: 4px; ${colorStyle}">
                                    ${stat.color}: ${stat.percentage}%
                                </div>
                            `;
                        });
                        
                        html += '</div></div>';
                    }
                } else if (result.color.error) {
                    html += `
                        <div style="background: #ffebee; padding: 15px; border-radius: 6px; margin: 10px 0; border-left: 4px solid #f44336;">
                            <h4>âŒ 4è‰²èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼</h4>
                            <p>${result.color.error}</p>
                        </div>
                    `;
                }
            }
            
            // æŠ€è¡“è©³ç´°
            if (result.gridSize) {
                html += `
                    <div class="stats">
                        <strong>æŠ€è¡“è©³ç´°:</strong> 
                        ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º: ${result.gridSize}x${result.gridSize}
                        ${result.moduleSize ? `, ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚µã‚¤ã‚º: ${result.moduleSize}px` : ''}
                    </div>
                `;
            }
            
            // ãƒ‡ãƒ¼ã‚¿æ¯”è¼ƒ
            if (result.standard && result.standard.data && result.color && result.color.data) {
                const isMatching = result.standard.data === result.color.data;
                html += `
                    <div style="background: ${isMatching ? '#e8f5e8' : '#fff3e0'}; padding: 10px; border-radius: 4px; margin: 10px 0;">
                        <strong>ğŸ“‹ ãƒ‡ãƒ¼ã‚¿æ¯”è¼ƒ:</strong> 
                        ${isMatching ? 'âœ… ä¸€è‡´' : 'âš ï¸ ä¸ä¸€è‡´ - 4è‰²QRã¯ç•°ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã®å¯èƒ½æ€§'}
                    </div>
                `;
            }
            
            resultDiv.innerHTML = html;
        }
        
        // 4è‰²QRç›´æ¥æ¤œå‡º
        function detectColorQR(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // ç”»åƒã‚’4è‰²ã«é‡å­åŒ–
            const quantizedImage = quantizeToFourColors(data, width, height);
            
            // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ã™
            const corners = findColorQRCorners(quantizedImage, width, height);
            
            if (corners.length < 3) {
                return { found: false };
            }
            
            try {
                // QRã‚³ãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚ºã‚’æ¨å®š
                const qrBounds = calculateQRBounds(corners, width, height);
                const estimatedSize = estimateQRSize(qrBounds);
                
                // ã‚°ãƒªãƒƒãƒ‰ã‚’æŠ½å‡º
                const colorGrid = extractColorGrid(quantizedImage, width, height, qrBounds, estimatedSize);
                
                // ãƒ‡ã‚³ãƒ¼ãƒ‰
                const decodedText = decodeColorQRDirect(colorGrid);
                
                if (decodedText && decodedText.length > 0) {
                    return {
                        found: true,
                        data: decodedText,
                        size: estimatedSize,
                        confidence: calculateConfidence(colorGrid),
                        corners: corners
                    };
                }
            } catch (error) {
                console.log('4è‰²QRãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error.message);
            }
            
            return { found: false };
        }
        
        // 4è‰²é‡å­åŒ–
        function quantizeToFourColors(imageData, width, height) {
            const quantized = new Array(width * height);
            
            for (let i = 0; i < imageData.length; i += 4) {
                const r = imageData[i];
                const g = imageData[i + 1];
                const b = imageData[i + 2];
                
                const colorIndex = findNearestColor([r, g, b]);
                quantized[i / 4] = colorIndex;
            }
            
            return quantized;
        }
        
        // 4è‰²QRã®è§’ã‚’æ¤œå‡º
        function findColorQRCorners(quantizedImage, width, height) {
            const corners = [];
            const patternSize = 7; // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚µã‚¤ã‚º
            
            // ç”»åƒã‚’åˆ†å‰²ã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ã™
            const stepSize = Math.max(5, Math.min(width, height) / 50);
            
            for (let y = 0; y < height - patternSize; y += stepSize) {
                for (let x = 0; x < width - patternSize; x += stepSize) {
                    if (isColorQRPositionPattern(quantizedImage, width, x, y, patternSize)) {
                        corners.push({ x: x + patternSize/2, y: y + patternSize/2 });
                        
                        // 4ã¤ã®è§’ãŒè¦‹ã¤ã‹ã£ãŸã‚‰çµ‚äº†
                        if (corners.length >= 4) {
                            return corners.slice(0, 4);
                        }
                    }
                }
            }
            
            return corners;
        }
        
        // 4è‰²QRä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ¤å®š
        function isColorQRPositionPattern(quantizedImage, width, startX, startY, patternSize) {
            // ç°¡æ˜“çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºï¼šãƒã‚§ãƒƒã‚«ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
            let alternatingCount = 0;
            let totalCells = 0;
            
            for (let dy = 0; dy < patternSize; dy++) {
                for (let dx = 0; dx < patternSize; dx++) {
                    const x = startX + dx;
                    const y = startY + dy;
                    
                    if (x < width && y < quantizedImage.length / width) {
                        const index = y * width + x;
                        const expected = (dx + dy) % 2; // ãƒã‚§ãƒƒã‚«ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³
                        const actual = quantizedImage[index];
                        
                        // é»’(0)ã¾ãŸã¯ç™½(1)ã®ãƒã‚§ãƒƒã‚«ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
                        if ((expected === 0 && actual === 0) || (expected === 1 && actual === 1)) {
                            alternatingCount++;
                        }
                        totalCells++;
                    }
                }
            }
            
            // 70%ä»¥ä¸ŠãŒãƒ‘ã‚¿ãƒ¼ãƒ³ã«ä¸€è‡´ã™ã‚‹å ´åˆã€ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã¨åˆ¤å®š
            return totalCells > 0 && (alternatingCount / totalCells) > 0.7;
        }
        
        // QRã‚³ãƒ¼ãƒ‰ã®å¢ƒç•Œè¨ˆç®—
        function calculateQRBounds(corners, width, height) {
            if (corners.length < 3) return null;
            
            // æœ€å°å¢ƒç•ŒçŸ©å½¢ã‚’è¨ˆç®—
            const minX = Math.min(...corners.map(c => c.x));
            const maxX = Math.max(...corners.map(c => c.x));
            const minY = Math.min(...corners.map(c => c.y));
            const maxY = Math.max(...corners.map(c => c.y));
            
            return {
                topLeft: { x: minX, y: minY },
                topRight: { x: maxX, y: minY },
                bottomLeft: { x: minX, y: maxY },
                bottomRight: { x: maxX, y: maxY },
                width: maxX - minX,
                height: maxY - minY
            };
        }
        
        // QRã‚µã‚¤ã‚ºæ¨å®š
        function estimateQRSize(bounds) {
            const avgDimension = (bounds.width + bounds.height) / 2;
            
            // ä¸€èˆ¬çš„ãªQRã‚µã‚¤ã‚ºã«è¿‘ä¼¼
            if (avgDimension < 100) return 21;
            if (avgDimension < 150) return 25;
            if (avgDimension < 200) return 29;
            if (avgDimension < 250) return 33;
            return 37;
        }
        
        // ã‚«ãƒ©ãƒ¼ã‚°ãƒªãƒƒãƒ‰æŠ½å‡º
        function extractColorGrid(quantizedImage, width, height, bounds, gridSize) {
            const cellWidth = bounds.width / gridSize;
            const cellHeight = bounds.height / gridSize;
            
            let colorGrid = [];
            
            for (let row = 0; row < gridSize; row++) {
                let gridRow = [];
                for (let col = 0; col < gridSize; col++) {
                    const centerX = Math.floor(bounds.topLeft.x + (col + 0.5) * cellWidth);
                    const centerY = Math.floor(bounds.topLeft.y + (row + 0.5) * cellHeight);
                    
                    if (centerX >= 0 && centerX < width && centerY >= 0 && centerY < height) {
                        const index = centerY * width + centerX;
                        gridRow.push(quantizedImage[index]);
                    } else {
                        gridRow.push(0); // ç¯„å›²å¤–ã¯é»’
                    }
                }
                colorGrid.push(gridRow);
            }
            
            return colorGrid;
        }
        
        // 4è‰²QRç›´æ¥ãƒ‡ã‚³ãƒ¼ãƒ‰
        function decodeColorQRDirect(colorGrid) {
            if (!colorGrid || colorGrid.length === 0) return null;
            
            let binaryString = '';
            const size = colorGrid.length;
            
            // ãƒ‡ãƒ¼ã‚¿é ˜åŸŸã®ã¿ã‚’å‡¦ç†ï¼ˆä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¿ã‘ã‚‹ï¼‰
            for (let y = 4; y < size - 4; y++) {
                for (let x = 4; x < colorGrid[y].length - 4; x++) {
                    // ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—
                    if (y === 3 || x === 3) continue;
                    
                    const colorIndex = colorGrid[y][x];
                    binaryString += colorIndex.toString(2).padStart(2, '0');
                }
            }
            
            // ãƒã‚¤ãƒŠãƒªã‚’æ–‡å­—åˆ—ã«å¤‰æ›
            let resultText = '';
            for (let i = 0; i < binaryString.length; i += 8) {
                const byte = binaryString.substr(i, 8);
                if (byte.length === 8) {
                    const charCode = parseInt(byte, 2);
                    if (charCode === 0) {
                        break; // çµ‚ç«¯
                    }
                    if (charCode >= 32 && charCode <= 126) {
                        resultText += String.fromCharCode(charCode);
                    }
                }
            }
            
            return resultText;
        }
        
        // ä¿¡é ¼åº¦è¨ˆç®—
        function calculateConfidence(colorGrid) {
            if (!colorGrid || colorGrid.length === 0) return 0;
            
            let validCells = 0;
            let totalCells = 0;
            
            for (let row of colorGrid) {
                for (let cell of row) {
                    if (cell >= 0 && cell <= 3) { // æœ‰åŠ¹ãª4è‰²ç¯„å›²
                        validCells++;
                    }
                    totalCells++;
                }
            }
            
            return totalCells > 0 ? Math.floor((validCells / totalCells) * 100) : 0;
        }
        
        function analyzeColorQRFromStandard(canvas, ctx, qrResult) {
            try {
                const corners = [
                    qrResult.location.topLeftCorner,
                    qrResult.location.topRightCorner,
                    qrResult.location.bottomRightCorner,
                    qrResult.location.bottomLeftCorner
                ];
                
                const width = Math.sqrt(
                    Math.pow(corners[1].x - corners[0].x, 2) + 
                    Math.pow(corners[1].y - corners[0].y, 2)
                );
                
                const moduleSize = width / 21;
                const gridSize = Math.round(width / moduleSize);
                
                const normalizedQR = extractNormalizedQR(canvas, ctx, corners, gridSize);
                const colorData = analyzeColorGrid(normalizedQR, gridSize);
                const decodedText = decodeColorQR(colorData);
                
                displayResult({
                    standard: qrResult.data,
                    color: decodedText,
                    gridSize: gridSize,
                    moduleSize: moduleSize.toFixed(2)
                });
                
            } catch (error) {
                displayResult({
                    standard: qrResult.data,
                    color: null,
                    error: error.message
                });
            }
        }
        
        function extractNormalizedQR(canvas, ctx, corners, size) {
            const tempCanvas = document.getElementById('tempCanvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCanvas.width = size * 10;
            tempCanvas.height = size * 10;
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const tempImageData = tempCtx.createImageData(tempCanvas.width, tempCanvas.height);
            
            for (let y = 0; y < tempCanvas.height; y++) {
                for (let x = 0; x < tempCanvas.width; x++) {
                    const u = x / tempCanvas.width;
                    const v = y / tempCanvas.height;
                    
                    const srcX = Math.round(
                        corners[0].x * (1-u) * (1-v) +
                        corners[1].x * u * (1-v) +
                        corners[2].x * u * v +
                        corners[3].x * (1-u) * v
                    );
                    
                    const srcY = Math.round(
                        corners[0].y * (1-u) * (1-v) +
                        corners[1].y * u * (1-v) +
                        corners[2].y * u * v +
                        corners[3].y * (1-u) * v
                    );
                    
                    if (srcX >= 0 && srcX < canvas.width && srcY >= 0 && srcY < canvas.height) {
                        const srcIndex = (srcY * canvas.width + srcX) * 4;
                        const dstIndex = (y * tempCanvas.width + x) * 4;
                        
                        tempImageData.data[dstIndex] = imageData.data[srcIndex];
                        tempImageData.data[dstIndex + 1] = imageData.data[srcIndex + 1];
                        tempImageData.data[dstIndex + 2] = imageData.data[srcIndex + 2];
                        tempImageData.data[dstIndex + 3] = 255;
                    }
                }
            }
            
            tempCtx.putImageData(tempImageData, 0, 0);
            return tempCanvas;
        }
        
        function analyzeColorGrid(canvas, gridSize) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const cellSize = canvas.width / gridSize;
            let colorGrid = [];
            
            for (let y = 0; y < gridSize; y++) {
                let row = [];
                for (let x = 0; x < gridSize; x++) {
                    const centerX = Math.floor((x + 0.5) * cellSize);
                    const centerY = Math.floor((y + 0.5) * cellSize);
                    
                    if (centerX < canvas.width && centerY < canvas.height) {
                        const pixelIndex = (centerY * canvas.width + centerX) * 4;
                        const r = data[pixelIndex];
                        const g = data[pixelIndex + 1];
                        const b = data[pixelIndex + 2];
                        
                        const colorIndex = findNearestColor([r, g, b]);
                        row.push(colorIndex);
                    } else {
                        row.push(0);
                    }
                }
                colorGrid.push(row);
            }
            
            return colorGrid;
        }
        
        function decodeColorQR(colorGrid) {
            let binaryString = '';
            
            for (let y = 9; y < colorGrid.length - 9; y++) {
                for (let x = 9; x < colorGrid[y].length - 9; x++) {
                    const colorIndex = colorGrid[y][x];
                    binaryString += colorIndex.toString(2).padStart(2, '0');
                }
            }
            
            let resultText = '';
            for (let i = 0; i < binaryString.length; i += 8) {
                const byte = binaryString.substr(i, 8);
                if (byte.length === 8) {
                    const charCode = parseInt(byte, 2);
                    if (charCode >= 32 && charCode <= 126) {
                        resultText += String.fromCharCode(charCode);
                    } else if (charCode === 0) {
                        break;
                    }
                }
            }
            
            return resultText;
        }
        
        function findNearestColor(rgb) {
            let minDistance = Infinity;
            let nearestIndex = 0;
            
            for (let i = 0; i < colors.length; i++) {
                const distance = Math.sqrt(
                    Math.pow(rgb[0] - colors[i][0], 2) +
                    Math.pow(rgb[1] - colors[i][1], 2) +
                    Math.pow(rgb[2] - colors[i][2], 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestIndex = i;
                }
            }
            
            return nearestIndex;
        }
        
        // è‰²çµ±è¨ˆæƒ…å ±å–å¾—
        function getColorStats(colorGrid) {
            let counts = [0, 0, 0, 0];
            let total = 0;
            
            for (let row of colorGrid) {
                for (let color of row) {
                    if (color >= 0 && color <= 3) {
                        counts[color]++;
                        total++;
                    }
                }
            }
            
            const colorNames = ['é»’', 'ç™½', 'é’', 'ç·‘'];
            return counts.map((count, i) => ({
                color: colorNames[i],
                count: count,
                percentage: total > 0 ? ((count / total) * 100).toFixed(1) : '0.0'
            }));
        }
        
        // æ¨™æº–QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
        function generateStandardQR() {
            const text = document.getElementById('input-text').value;
            if (!text) {
                showStatus('ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            try {
                const cellSize = parseInt(document.getElementById('cell-size').value);
                
                // æ¨™æº–QRã‚³ãƒ¼ãƒ‰ã®ã‚¨ãƒ©ãƒ¼è¨‚æ­£ãƒ¬ãƒ™ãƒ«ãƒãƒƒãƒ”ãƒ³ã‚°
                const errorLevelMap = {
                    '10': 'L',
                    '20': 'M', 
                    '30': 'Q',
                    '40': 'H'
                };
                const errorLevel = errorLevelMap[document.getElementById('error-level').value];
                
                const qr = qrcode(0, errorLevel);
                qr.addData(text);
                qr.make();
                
                const moduleCount = qr.getModuleCount();
                
                const output = document.getElementById('qr-output');
                output.innerHTML = `
                    <div class="qr-container">
                        <h4>æ¨™æº–QRã‚³ãƒ¼ãƒ‰</h4>
                        ${qr.createImgTag(cellSize)}
                        <div class="stats">
                            ã‚µã‚¤ã‚º: ${moduleCount}x${moduleCount}<br>
                            ç·ã‚»ãƒ«æ•°: ${moduleCount * moduleCount}<br>
                            ã‚¨ãƒ©ãƒ¼è¨‚æ­£: ${errorLevel}<br>
                            ãƒ‡ãƒ¼ã‚¿é‡: ${text.length}æ–‡å­—<br>
                            æƒ…å ±å¯†åº¦: 1ãƒ“ãƒƒãƒˆ/ã‚»ãƒ«
                        </div>
                    </div>
                `;
                
                showStatus('æ¨™æº–QRã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¾ã—ãŸ', 'success');
            } catch (error) {
                showStatus('ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
            }
        }
        
        // æœ€é©åŒ–4è‰²QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
        function generateOptimizedColorQR() {
            const text = document.getElementById('input-text').value;
            if (!text) {
                showStatus('ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            try {
                const errorCorrectionRate = parseInt(document.getElementById('error-level').value);
                const cellSize = parseInt(document.getElementById('cell-size').value);
                const optimization = document.getElementById('optimization').value;
                
                // Reed-Solomon ã‚¨ãƒ©ãƒ¼è¨‚æ­£
                const rs = new ReedSolomon(errorCorrectionRate);
                const encoded = rs.encode(text);
                
                // æœ€é©ã‚µã‚¤ã‚ºè¨ˆç®—
                const optimalSize = calculateOptimalSize(encoded.totalBytes, errorCorrectionRate, optimization);
                
                // æ¨™æº–QRã‚³ãƒ¼ãƒ‰ã‚‚ç”Ÿæˆï¼ˆæ¯”è¼ƒç”¨ï¼‰
                const errorLevelMap = { '10': 'L', '20': 'M', '30': 'Q', '40': 'H' };
                const standardQR = qrcode(0, errorLevelMap[errorCorrectionRate]);
                standardQR.addData(text);
                standardQR.make();
                const standardSize = standardQR.getModuleCount();
                
                // 4è‰²QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
                const colorGrid = generateOptimizedColorGrid(encoded, optimalSize);
                
                displayOptimizedComparison(standardQR, colorGrid, optimalSize, standardSize, cellSize, text, encoded, errorCorrectionRate);
                
                showStatus('æœ€é©åŒ–4è‰²QRã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¾ã—ãŸ', 'success');
            } catch (error) {
                showStatus('ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
            }
        }
        
        // æœ€é©åŒ–ã‚«ãƒ©ãƒ¼ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ
        function generateOptimizedColorGrid(encoded, size) {
            let colorGrid = [];
            
            // ãƒ‡ãƒ¼ã‚¿æº–å‚™ï¼šã‚¨ãƒ©ãƒ¼è¨‚æ­£ã‚’å«ã‚€å…¨ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚¤ãƒŠãƒªåŒ–
            let binaryString = '';
            
            // å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿
            for (let i = 0; i < encoded.data.length; i++) {
                binaryString += encoded.data.charCodeAt(i).toString(2).padStart(8, '0');
            }
            
            // ã‚¨ãƒ©ãƒ¼è¨‚æ­£ãƒ‡ãƒ¼ã‚¿
            for (let i = 0; i < encoded.errorCorrection.length; i++) {
                binaryString += encoded.errorCorrection[i].toString(2).padStart(8, '0');
            }
            
            // çµ‚ç«¯ãƒãƒ¼ã‚«ãƒ¼
            binaryString += '00000000'; // çµ‚ç«¯
            
            // 2ãƒ“ãƒƒãƒˆãšã¤ã«åˆ†å‰²ï¼ˆ4è‰²å¯¾å¿œï¼‰
            let colorIndices = [];
            for (let i = 0; i < binaryString.length; i += 2) {
                const twoBits = binaryString.substr(i, 2).padEnd(2, '0');
                colorIndices.push(parseInt(twoBits, 2));
            }
            
            let colorIndex = 0;
            
            for (let row = 0; row < size; row++) {
                let gridRow = [];
                for (let col = 0; col < size; col++) {
                    // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç°¡ç•¥åŒ–ï¼‰
                    if (isPositionDetectionPattern(row, col, size) || isTimingPattern(row, col)) {
                        // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã¯é»’ç™½ã®ãƒã‚§ãƒƒã‚«ãƒ¼ãƒœãƒ¼ãƒ‰
                        gridRow.push((row + col) % 2 === 0 ? 0 : 1);
                    } else {
                        // ãƒ‡ãƒ¼ã‚¿é ˜åŸŸï¼š4è‰²ã§åŠ¹ç‡çš„ã«é…ç½®
                        if (colorIndex < colorIndices.length) {
                            gridRow.push(colorIndices[colorIndex]);
                            colorIndex++;
                        } else {
                            gridRow.push(0); // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
                        }
                    }
                }
                colorGrid.push(gridRow);
            }
            
            return colorGrid;
        }
        
        // ä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ¤å®šï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
        function isPositionDetectionPattern(row, col, size) {
            // 4ã¤è§’ã«å°ã•ãªä½ç½®æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³
            const patternSize = 7;
            return (row < patternSize && col < patternSize) || 
                   (row < patternSize && col >= size - patternSize) || 
                   (row >= size - patternSize && col < patternSize) ||
                   (row >= size - patternSize && col >= size - patternSize);
        }
        
        // ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ¤å®šï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
        function isTimingPattern(row, col) {
            return (row === 3) || (col === 3); // ã‚ˆã‚Šå°ã•ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³
        }
        
        // æœ€é©åŒ–æ¯”è¼ƒè¡¨ç¤º
        function displayOptimizedComparison(standardQR, colorGrid, colorSize, standardSize, cellSize, text, encoded, errorRate) {
            const output = document.getElementById('qr-output');
            
            // åŠ¹ç‡æ€§è¨ˆç®—
            const standardCells = standardSize * standardSize;
            const colorCells = colorSize * colorSize;
            const sizeReduction = ((standardCells - colorCells) / standardCells * 100).toFixed(1);
            const efficiencyGain = ((standardCells / colorCells - 1) * 100).toFixed(1);
            
            // æ¯”è¼ƒæƒ…å ±
            let comparisonHTML = `
                <div class="comparison">
                    <h4>ğŸ“Š åŠ¹ç‡æ€§æ¯”è¼ƒ</h4>
                    <p><strong>ãƒ‡ãƒ¼ã‚¿:</strong> "${text}" (${text.length}æ–‡å­—)</p>
                    <p><strong>ã‚¨ãƒ©ãƒ¼è¨‚æ­£:</strong> ${errorRate}% (${encoded.errorCorrection.length}ãƒã‚¤ãƒˆè¿½åŠ )</p>
                    <p><strong>ã‚µã‚¤ã‚ºå‰Šæ¸›:</strong> ${standardCells}ã‚»ãƒ« â†’ ${colorCells}ã‚»ãƒ« (-${sizeReduction}%)</p>
                    <p><strong>åŠ¹ç‡å‘ä¸Š:</strong> +${efficiencyGain}%</p>
                </div>
            `;
            
            // æ¨™æº–QRã‚³ãƒ¼ãƒ‰
            let standardHTML = `
                <div class="qr-container">
                    <h4>æ¨™æº–QRã‚³ãƒ¼ãƒ‰</h4>
                    ${standardQR.createImgTag(cellSize)}
                    <div class="stats">
                        ã‚µã‚¤ã‚º: ${standardSize}x${standardSize}<br>
                        ç·ã‚»ãƒ«æ•°: ${standardCells}<br>
                        ã‚¨ãƒ©ãƒ¼è¨‚æ­£: Reed-Solomon<br>
                        ãƒ‡ãƒ¼ã‚¿é‡: ${text.length}æ–‡å­—<br>
                        æƒ…å ±å¯†åº¦: 1ãƒ“ãƒƒãƒˆ/ã‚»ãƒ«
                    </div>
                </div>
            `;
            
            // æœ€é©åŒ–4è‰²QRã‚³ãƒ¼ãƒ‰
            let colorHTML = `
                <div class="qr-container">
                    <h4>æœ€é©åŒ–4è‰²QRã‚³ãƒ¼ãƒ‰ 
                        <span class="size-badge">-${sizeReduction}% ã‚µã‚¤ã‚º</span>
                        <span class="efficiency-badge">+${efficiencyGain}% åŠ¹ç‡</span>
                    </h4>
                    <div class="qr-grid">
            `;
            
            for (let row of colorGrid) {
                colorHTML += '<div class="qr-row">';
                for (let colorIndex of row) {
                    const color = colors[colorIndex];
                    const rgbString = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    colorHTML += `<div class="qr-cell" style="background-color: ${rgbString}; width: ${cellSize}px; height: ${cellSize}px;"></div>`;
                }
                colorHTML += '</div>';
            }
            
            const dataCapacity = colorCells - Math.floor(colorCells * 0.3); // 30%ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¨ã—ã¦æ¦‚ç®—
            
            colorHTML += `
                    </div>
                    <div class="stats">
                        ã‚µã‚¤ã‚º: ${colorSize}x${colorSize}<br>
                        ç·ã‚»ãƒ«æ•°: ${colorCells}<br>
                        ã‚¨ãƒ©ãƒ¼è¨‚æ­£: ç°¡æ˜“Reed-Solomon (${errorRate}%)<br>
                        ãƒ‡ãƒ¼ã‚¿é‡: ${text.length}æ–‡å­—<br>
                        æƒ…å ±å¯†åº¦: 2ãƒ“ãƒƒãƒˆ/ã‚»ãƒ«<br>
                        ç†è«–å®¹é‡: ç´„${Math.floor(dataCapacity/4)}æ–‡å­—<br>
                        <strong>ã‚µã‚¤ã‚ºå‰Šæ¸›: ${sizeReduction}%</strong>
                    </div>
                </div>
            `;
            
            output.innerHTML = comparisonHTML + standardHTML + colorHTML;
        }
        
        // å‡ºåŠ›ã‚¯ãƒªã‚¢
        function clearOutput() {
            document.getElementById('qr-output').innerHTML = '';
            document.getElementById('input-text').value = '';
        }
        
        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
        function showStatus(message, type) {
            const existingStatus = document.querySelector('.status');
            if (existingStatus) {
                existingStatus.remove();
            }
            
            const status = document.createElement('div');
            status.className = `status ${type}`;
            status.textContent = message;
            
            document.querySelector('.container').appendChild(status);
            
            setTimeout(() => {
                if (status.parentNode) {
                    status.remove();
                }
            }, 3000);
        }
        
        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã®åˆæœŸåŒ–
        window.addEventListener('load', () => {
            showStatus('æœ€é©åŒ–4è‰²QRã‚³ãƒ¼ãƒ‰ã‚¢ãƒ—ãƒªãŒæº–å‚™å®Œäº†ã§ã™', 'info');
            
            // ã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®š
            document.getElementById('input-text').value = 'Hello World! This is an optimized 4-color QR code with Reed-Solomon error correction. ğŸš€';
        });
        
        // ãƒšãƒ¼ã‚¸ã‚’é–‰ã˜ã‚‹éš›ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        window.addEventListener('beforeunload', () => {
            stopCamera();
        });
    </script>
</body>
</html>