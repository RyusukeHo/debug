<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI QRストリーミング - 大チャンク対応版</title>
    <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://unpkg.com/qrious@4.0.2/dist/qrious.min.js"></script>
    <script src="https://unpkg.com/@tonejs/midi@2.0.28/build/Midi.js"></script>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h2 {
            margin-top: 0;
            color: #333;
        }

        video,
        canvas {
            width: 100%;
            max-width: 400px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }

        .controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        input[type="file"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 80px;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status.playing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.preparing {
            background: #e2e3e5;
            color: #383d41;
            border: 1px solid #d6d8db;
        }

        .flash-display {
            text-align: center;
            padding: 20px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qr-canvas {
            border: 2px solid #333;
            max-width: 100%;
        }

        .label {
            font-weight: bold;
            margin-right: 10px;
        }

        .midi-info {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }

        .big-chunk-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
        }

        .audio-status {
            background: #f0f8e8;
            border: 1px solid #c6e5b3;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
        }

        .playback-controls {
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- 受信・再生側 -->
        <div class="panel">
            <h2>🎵 MIDI受信・再生 (大チャンク対応)</h2>

            <video id="video" autoplay></video>
            <canvas id="canvas" style="display: none;"></canvas>

            <div class="controls">
                <button id="startBtn">カメラ開始</button>
                <button id="stopBtn" disabled>停止</button>
                <button id="clearBtn">クリア</button>
                <button id="playBtn" disabled>再生</button>
                <button id="stopPlayBtn" disabled>停止</button>
            </div>

            <div class="controls">
                <span class="label">大チャンクサイズ:</span>
                <input type="number" id="bigChunkSize" value="4" min="2" max="10" step="1">
                <span>チャンク</span>
                <label>
                    <input type="checkbox" id="autoPlay" checked>
                    自動再生
                </label>
                <label>
                    <input type="checkbox" id="debugMode">
                    デバッグ
                </label>
            </div>

            <div class="playback-controls">
                <span class="label">再生開始位置:</span>
                <input type="number" id="playStartTime" value="0" min="0" step="0.1">
                <span>秒</span>
                <button id="playFromBtn" disabled>指定位置から再生</button>
            </div>

            <div id="receiverStatus" class="status info">カメラを開始してください</div>

            <div class="progress-bar">
                <div id="receivedProgress" class="progress-fill" style="background: #bee5eb; z-index: 1;"></div>
                <div id="bigChunkProgress" class="progress-fill"
                    style="background: #ffeaa7; z-index: 2; position: absolute; top: 0;"></div>
                <div id="playProgress" class="progress-fill"
                    style="background: #007bff; z-index: 3; position: absolute; top: 0;"></div>
            </div>

            <div class="big-chunk-info" id="bigChunkInfo">
                大チャンク情報がここに表示されます...
            </div>

            <div class="audio-status" id="audioStatus">
                音声準備状況がここに表示されます...
            </div>

            <div class="midi-info" id="midiInfo">
                MIDIデータの受信を待っています...
            </div>
        </div>

        <!-- 送信側 -->
        <div class="panel">
            <h2>📤 MIDI送信 (超圧縮版)</h2>

            <div class="controls">
                <input type="file" id="midiFile" accept=".mid,.midi" />
                <button id="loadMidiBtn">MIDI読み込み</button>
            </div>

            <div class="controls">
                <span class="label">チャンク音符数:</span>
                <input type="number" id="chunkNoteCount" value="20" min="10" max="50" step="5">
                <span class="label">送信FPS:</span>
                <input type="number" id="flashFPS" value="10" min="5" max="20">
            </div>

            <div class="controls">
                <button id="generateBtn" disabled>QRコード生成</button>
                <button id="flashBtn" disabled>フラッシュ開始</button>
                <button id="stopFlashBtn" disabled>フラッシュ停止</button>
            </div>

            <div id="senderStatus" class="status info">MIDIファイルを選択してください</div>

            <div class="flash-display">
                <canvas id="qrCanvas" class="qr-canvas"></canvas>
            </div>

            <div class="controls">
                <span class="label">進行状況:</span>
                <span id="progressDisplay">0 / 0</span>
                <span class="label">データサイズ:</span>
                <span id="dataSizeDisplay">0B</span>
            </div>

            <div class="midi-info" id="senderMidiInfo">
                MIDIファイル情報がここに表示されます...
            </div>
        </div>
    </div>

    <script>
        class MIDIQRStreaming {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.qrCanvas = document.getElementById('qrCanvas');

                // 受信側
                this.isScanning = false;
                this.receivedChunks = new Map(); // index -> chunk data
                this.bigChunks = new Map(); // bigChunkId -> big chunk data
                this.preparedAudio = new Map(); // bigChunkId -> prepared audio
                this.isPlaying = false;
                this.synth = null;
                this.playbackStartTime = null;
                this.currentPlaybackTime = 0;
                this.playStartOffset = 0;

                // 大チャンク管理
                this.currentBigChunkId = 0;
                this.audioPreparationQueue = [];
                this.isPreparingAudio = false;

                // 送信側
                this.originalMidi = null;
                this.qrChunks = [];
                this.flashInterval = null;
                this.currentChunkIndex = 0;

                this.initializeElements();
                this.setupEventListeners();
            }

            initializeElements() {
                // 受信側
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.playBtn = document.getElementById('playBtn');
                this.stopPlayBtn = document.getElementById('stopPlayBtn');
                this.playFromBtn = document.getElementById('playFromBtn');
                this.autoPlay = document.getElementById('autoPlay');
                this.debugMode = document.getElementById('debugMode');
                this.bigChunkSize = document.getElementById('bigChunkSize');
                this.playStartTime = document.getElementById('playStartTime');
                this.receiverStatus = document.getElementById('receiverStatus');
                this.midiInfo = document.getElementById('midiInfo');
                this.bigChunkInfo = document.getElementById('bigChunkInfo');
                this.audioStatus = document.getElementById('audioStatus');
                this.receivedProgress = document.getElementById('receivedProgress');
                this.bigChunkProgress = document.getElementById('bigChunkProgress');
                this.playProgress = document.getElementById('playProgress');

                // 送信側
                this.midiFile = document.getElementById('midiFile');
                this.loadMidiBtn = document.getElementById('loadMidiBtn');
                this.chunkNoteCount = document.getElementById('chunkNoteCount');
                this.flashFPS = document.getElementById('flashFPS');
                this.generateBtn = document.getElementById('generateBtn');
                this.flashBtn = document.getElementById('flashBtn');
                this.stopFlashBtn = document.getElementById('stopFlashBtn');
                this.senderStatus = document.getElementById('senderStatus');
                this.progressDisplay = document.getElementById('progressDisplay');
                this.dataSizeDisplay = document.getElementById('dataSizeDisplay');
                this.senderMidiInfo = document.getElementById('senderMidiInfo');
            }

            setupEventListeners() {
                // 受信側
                this.startBtn.addEventListener('click', () => this.startCamera());
                this.stopBtn.addEventListener('click', () => this.stopCamera());
                this.clearBtn.addEventListener('click', () => this.clearData());
                this.playBtn.addEventListener('click', () => this.playMidi());
                this.playFromBtn.addEventListener('click', () => this.playFromTime());
                this.stopPlayBtn.addEventListener('click', () => this.stopMidi());

                // 送信側
                this.loadMidiBtn.addEventListener('click', () => this.loadMidiFile());
                this.generateBtn.addEventListener('click', () => this.generateQRCodes());
                this.flashBtn.addEventListener('click', () => this.startFlashing());
                this.stopFlashBtn.addEventListener('click', () => this.stopFlashing());
            }

            async initializeAudio() {
                try {
                    await Tone.start();
                    this.synth = new Tone.PolySynth(Tone.Synth).toDestination();
                    console.log('Audio initialized');
                    return true;
                } catch (error) {
                    console.error('Audio init failed:', error);
                    return false;
                }
            }

            // カメラ関連
            async startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' }
                    });
                    this.video.srcObject = stream;
                    this.video.addEventListener('loadedmetadata', () => {
                        this.canvas.width = this.video.videoWidth;
                        this.canvas.height = this.video.videoHeight;
                        this.startScanning();
                    });

                    this.startBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    this.updateReceiverStatus('カメラ開始', 'success');
                } catch (error) {
                    this.updateReceiverStatus('カメラエラー: ' + error.message, 'error');
                }
            }

            stopCamera() {
                this.isScanning = false;
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                    this.video.srcObject = null;
                }
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.updateReceiverStatus('カメラ停止', 'info');
            }

            startScanning() {
                this.isScanning = true;
                this.scanFrame();
            }

            scanFrame() {
                if (!this.isScanning) return;

                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);

                if (code) {
                    this.processQRCode(code.data);
                }

                requestAnimationFrame(() => this.scanFrame());
            }

            // 超圧縮QRコード処理
            processQRCode(data) {
                try {
                    if (data.startsWith('M:')) {
                        const compressedArray = JSON.parse(data.substring(2));

                        // 数字配列から元データを復元
                        const chunkData = this.decompressChunkData(compressedArray);

                        // 重複チェック
                        if (this.receivedChunks.has(chunkData.index)) {
                            return;
                        }

                        this.receivedChunks.set(chunkData.index, chunkData);

                        const totalNotes = chunkData.timeGroups.reduce((sum, group) => sum + group.notes.length, 0);
                        this.updateReceiverStatus(
                            `チャンク ${chunkData.index + 1} 受信 (${totalNotes}音符)`,
                            'success'
                        );

                        this.updateMidiInfo();
                        this.updateProgress();
                        this.createBigChunks();
                        this.prepareAudio();
                        this.tryAutoPlay();
                    }
                } catch (error) {
                    console.error('QR処理エラー:', error);
                }
            }

            // 数字配列から元データを復元
            decompressChunkData(arr) {
                return {
                    index: arr[0],
                    total: arr[1],
                    tempo: arr[2],
                    startTime: arr[3] / 1000, // ms -> s
                    endTime: arr[4] / 1000,
                    timeGroups: this.decompressTimeGroups(arr.slice(5))
                };
            }

            decompressTimeGroups(data) {
                const groups = [];
                let i = 0;

                while (i < data.length) {
                    const time = data[i] / 1000; // ms -> s
                    const noteCount = data[i + 1];
                    const notes = [];

                    for (let j = 0; j < noteCount; j++) {
                        const noteIndex = i + 2 + j * 3;
                        notes.push({
                            pitch: this.indexToNoteName(data[noteIndex]),
                            duration: data[noteIndex + 1] / 1000, // ms -> s
                            velocity: data[noteIndex + 2] / 127 // 0-127 -> 0-1
                        });
                    }

                    groups.push({ time, notes });
                    i += 2 + noteCount * 3;
                }

                return groups;
            }

            // 音符番号から音符名に変換
            indexToNoteName(index) {
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const octave = Math.floor(index / 12) - 1;
                const note = noteNames[index % 12];
                return note + octave;
            }

            // 大チャンク作成
            createBigChunks() {
                const bigChunkSize = parseInt(this.bigChunkSize.value);
                const sortedIndices = Array.from(this.receivedChunks.keys()).sort((a, b) => a - b);

                // 連続するチャンクをグループ化
                let currentGroup = [];
                let lastIndex = -1;

                for (const index of sortedIndices) {
                    if (lastIndex === -1 || index === lastIndex + 1) {
                        currentGroup.push(index);
                        if (currentGroup.length >= bigChunkSize) {
                            this.createBigChunk(currentGroup);
                            currentGroup = [];
                        }
                    } else {
                        if (currentGroup.length > 0) {
                            this.createBigChunk(currentGroup);
                        }
                        currentGroup = [index];
                    }
                    lastIndex = index;
                }

                // 残りのグループも処理
                if (currentGroup.length >= 2) { // 最低2チャンクで大チャンク作成
                    this.createBigChunk(currentGroup);
                }
            }

            createBigChunk(chunkIndices) {
                const bigChunkId = chunkIndices.join('-');

                if (this.bigChunks.has(bigChunkId)) {
                    return;
                }

                // チャンクを結合
                const chunks = chunkIndices.map(index => this.receivedChunks.get(index));
                const allTimeGroups = [];

                chunks.forEach(chunk => {
                    allTimeGroups.push(...chunk.timeGroups);
                });

                // 時間順にソート
                allTimeGroups.sort((a, b) => a.time - b.time);

                const bigChunk = {
                    id: bigChunkId,
                    chunkIndices: chunkIndices,
                    startTime: chunks[0].startTime,
                    endTime: chunks[chunks.length - 1].endTime,
                    timeGroups: allTimeGroups,
                    tempo: chunks[0].tempo
                };

                this.bigChunks.set(bigChunkId, bigChunk);

                if (this.debugMode.checked) {
                    console.log(`大チャンク作成: ${bigChunkId} (${allTimeGroups.length}タイムグループ)`);
                }

                this.updateBigChunkInfo();
                this.updateProgress();
            }

            // 音声準備システム
            async prepareAudio() {
                if (this.isPreparingAudio) return;

                // 未準備の大チャンクを探す
                const unpreparedBigChunks = Array.from(this.bigChunks.keys())
                    .filter(id => !this.preparedAudio.has(id));

                if (unpreparedBigChunks.length === 0) return;

                this.isPreparingAudio = true;
                this.updateReceiverStatus('音声準備中...', 'preparing');

                for (const bigChunkId of unpreparedBigChunks) {
                    await this.prepareBigChunkAudio(bigChunkId);
                }

                this.isPreparingAudio = false;
                this.updateAudioStatus();

                // 再生可能になったかチェック
                if (!this.isPlaying && this.preparedAudio.size > 0) {
                    this.playBtn.disabled = false;
                    this.playFromBtn.disabled = false;
                }
            }

            async prepareBigChunkAudio(bigChunkId) {
                const bigChunk = this.bigChunks.get(bigChunkId);
                if (!bigChunk) return;

                // 音符データを事前処理
                const preparedNotes = [];

                bigChunk.timeGroups.forEach(timeGroup => {
                    timeGroup.notes.forEach(note => {
                        preparedNotes.push({
                            time: timeGroup.time,
                            pitch: note.pitch,
                            duration: note.duration,
                            velocity: note.velocity,
                            scheduled: false
                        });
                    });
                });

                // 時間順にソート
                preparedNotes.sort((a, b) => a.time - b.time);

                const audioData = {
                    bigChunkId: bigChunkId,
                    startTime: bigChunk.startTime,
                    endTime: bigChunk.endTime,
                    notes: preparedNotes,
                    prepared: true
                };

                this.preparedAudio.set(bigChunkId, audioData);

                if (this.debugMode.checked) {
                    console.log(`音声準備完了: ${bigChunkId} (${preparedNotes.length}音符)`);
                }
            }

            // 再生システム
            async playMidi(startTime = 0) {
                if (this.preparedAudio.size === 0) {
                    this.updateReceiverStatus('再生可能な音声データがありません', 'error');
                    return;
                }

                if (!this.synth) {
                    const success = await this.initializeAudio();
                    if (!success) {
                        this.updateReceiverStatus('オーディオ初期化失敗', 'error');
                        return;
                    }
                }

                this.isPlaying = true;
                this.playBtn.disabled = true;
                this.playFromBtn.disabled = true;
                this.stopPlayBtn.disabled = false;
                this.playbackStartTime = Date.now();
                this.playStartOffset = startTime;
                this.currentPlaybackTime = startTime;

                // 指定時刻以降の音符をスケジュール
                this.scheduleNotesFromTime(startTime);

                this.updateReceiverStatus(`再生中... (${startTime.toFixed(1)}s から)`, 'playing');
                this.startPlaybackTimer();
            }

            async playFromTime() {
                const startTime = parseFloat(this.playStartTime.value);
                await this.playMidi(startTime);
            }

            scheduleNotesFromTime(startTime) {
                // 指定時刻以降に再生可能な大チャンクを特定
                const availableBigChunks = Array.from(this.preparedAudio.values())
                    .filter(audioData => audioData.endTime > startTime)
                    .sort((a, b) => a.startTime - b.startTime);

                if (this.debugMode.checked) {
                    console.log(`${startTime}s以降の大チャンク: ${availableBigChunks.length}個`);
                }

                // 各大チャンクの音符をリセット
                availableBigChunks.forEach(audioData => {
                    audioData.notes.forEach(note => {
                        note.scheduled = note.time < startTime;
                    });
                });
            }

            startPlaybackTimer() {
                this.playbackScheduler = setInterval(() => {
                    if (!this.isPlaying) return;

                    this.currentPlaybackTime = this.playStartOffset + (Date.now() - this.playbackStartTime) / 1000;

                    // 現在時刻で再生すべき音符を探す
                    const tolerance = 0.03; // 30msの許容範囲
                    let notesPlayed = 0;

                    this.preparedAudio.forEach(audioData => {
                        // 現在時刻に該当する音符をチェック
                        audioData.notes.forEach(note => {
                            if (!note.scheduled &&
                                note.time <= this.currentPlaybackTime + tolerance &&
                                note.time >= this.currentPlaybackTime - tolerance) {

                                try {
                                    this.synth.triggerAttackRelease(
                                        note.pitch,
                                        note.duration || 0.5,
                                        undefined,
                                        note.velocity || 0.8
                                    );
                                    note.scheduled = true;
                                    notesPlayed++;
                                } catch (error) {
                                    console.error('音符再生エラー:', error, note);
                                }
                            }
                        });
                    });

                    if (this.debugMode.checked && notesPlayed > 0) {
                        console.log(`時刻 ${this.currentPlaybackTime.toFixed(3)}s: ${notesPlayed}音符再生`);
                    }

                    this.updateProgress();
                    this.updateAudioStatus();

                }, 15); // 15ms間隔で高精度チェック
            }

            stopMidi() {
                this.isPlaying = false;
                this.playBtn.disabled = false;
                this.playFromBtn.disabled = false;
                this.stopPlayBtn.disabled = true;

                if (this.playbackScheduler) {
                    clearInterval(this.playbackScheduler);
                    this.playbackScheduler = null;
                }

                if (this.synth) {
                    this.synth.releaseAll();
                }

                this.updateReceiverStatus('停止', 'info');
                this.updateProgress();
            }

            async tryAutoPlay() {
                if (!this.autoPlay.checked || this.isPlaying || this.isPreparingAudio) {
                    return;
                }

                // 十分な大チャンクが準備できているかチェック
                if (this.preparedAudio.size >= 2) {
                    await this.playMidi();
                }
            }

            // 表示更新メソッド
            updateMidiInfo() {
                const totalChunks = this.receivedChunks.size > 0 ?
                    Math.max(...Array.from(this.receivedChunks.values()).map(c => c.total)) : 0;

                let info = `=== 受信状況 ===\n`;
                info += `小チャンク: ${this.receivedChunks.size} / ${totalChunks}\n`;
                info += `大チャンク: ${this.bigChunks.size}\n`;
                info += `音声準備済み: ${this.preparedAudio.size}\n\n`;

                // 受信チャンクの詳細
                const sortedChunks = Array.from(this.receivedChunks.values())
                    .sort((a, b) => a.index - b.index);

                sortedChunks.forEach(chunk => {
                    const totalNotes = chunk.timeGroups.reduce((sum, group) => sum + group.notes.length, 0);
                    const duration = chunk.endTime - chunk.startTime;
                    info += `小${chunk.index + 1}: ${totalNotes}音符 ${duration.toFixed(1)}s\n`;
                });

                this.midiInfo.textContent = info;
            }

            updateBigChunkInfo() {
                let info = `=== 大チャンク状況 ===\n`;

                const sortedBigChunks = Array.from(this.bigChunks.values())
                    .sort((a, b) => a.startTime - b.startTime);

                sortedBigChunks.forEach(bigChunk => {
                    const prepared = this.preparedAudio.has(bigChunk.id) ? '✓' : '○';
                    const totalNotes = bigChunk.timeGroups.reduce((sum, group) => sum + group.notes.length, 0);
                    const duration = bigChunk.endTime - bigChunk.startTime;

                    info += `${prepared} 大${bigChunk.id}: ${totalNotes}音符 `;
                    info += `${bigChunk.startTime.toFixed(1)}s-${bigChunk.endTime.toFixed(1)}s (${duration.toFixed(1)}s)\n`;
                    info += `    含む小チャンク: ${bigChunk.chunkIndices.map(i => i + 1).join(',')}\n`;
                });

                this.bigChunkInfo.textContent = info;
            }

            updateAudioStatus() {
                let info = `=== 音声状況 ===\n`;
                info += `準備完了: ${this.preparedAudio.size} / ${this.bigChunks.size}\n`;

                if (this.isPlaying) {
                    info += `再生時刻: ${this.currentPlaybackTime.toFixed(2)}s\n`;

                    // 現在再生中の大チャンクを特定
                    const currentBigChunk = Array.from(this.preparedAudio.values())
                        .find(audioData =>
                            this.currentPlaybackTime >= audioData.startTime &&
                            this.currentPlaybackTime <= audioData.endTime);

                    if (currentBigChunk) {
                        info += `再生中: 大${currentBigChunk.bigChunkId}\n`;
                    }

                    // 次の大チャンク
                    const nextBigChunk = Array.from(this.preparedAudio.values())
                        .filter(audioData => audioData.startTime > this.currentPlaybackTime)
                        .sort((a, b) => a.startTime - b.startTime)[0];

                    if (nextBigChunk) {
                        const timeToNext = nextBigChunk.startTime - this.currentPlaybackTime;
                        info += `次: 大${nextBigChunk.bigChunkId} (${timeToNext.toFixed(1)}s後)\n`;
                    }
                }

                this.audioStatus.textContent = info;
            }

            updateProgress() {
                // 受信進捗
                const totalChunks = this.receivedChunks.size > 0 ?
                    Math.max(...Array.from(this.receivedChunks.values()).map(c => c.total)) : 0;
                const receivedPercent = totalChunks > 0 ? (this.receivedChunks.size / totalChunks) * 100 : 0;
                this.receivedProgress.style.width = `${receivedPercent}%`;

                // 大チャンク進捗
                const bigChunkPercent = this.bigChunks.size > 0 ? (this.preparedAudio.size / this.bigChunks.size) * 100 : 0;
                this.bigChunkProgress.style.width = `${bigChunkPercent}%`;

                // 再生進捗
                if (this.isPlaying && this.preparedAudio.size > 0) {
                    const maxEndTime = Math.max(...Array.from(this.preparedAudio.values()).map(a => a.endTime));
                    const playPercent = maxEndTime > 0 ? (this.currentPlaybackTime / maxEndTime) * 100 : 0;
                    this.playProgress.style.width = `${Math.min(100, playPercent)}%`;
                } else {
                    this.playProgress.style.width = '0%';
                }
            }

            clearData() {
                this.receivedChunks.clear();
                this.bigChunks.clear();
                this.preparedAudio.clear();
                this.stopMidi();
                this.midiInfo.textContent = 'MIDIデータの受信を待っています...';
                this.bigChunkInfo.textContent = '大チャンク情報がここに表示されます...';
                this.audioStatus.textContent = '音声準備状況がここに表示されます...';
                this.updateProgress();
                this.updateReceiverStatus('データクリア', 'info');
            }

            updateReceiverStatus(message, type) {
                this.receiverStatus.textContent = message;
                this.receiverStatus.className = `status ${type}`;
            }

            // 送信側メソッド
            async loadMidiFile() {
                const file = this.midiFile.files[0];
                if (!file) {
                    this.updateSenderStatus('ファイルを選択してください', 'error');
                    return;
                }

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.originalMidi = new Midi(arrayBuffer);

                    this.displayMidiInfo();
                    this.generateBtn.disabled = false;
                    this.updateSenderStatus('MIDI読み込み完了', 'success');
                } catch (error) {
                    this.updateSenderStatus('読み込みエラー: ' + error.message, 'error');
                }
            }

            displayMidiInfo() {
                if (!this.originalMidi) return;

                const chunkNoteCount = parseInt(this.chunkNoteCount.value);
                const totalNotes = this.originalMidi.tracks.reduce((sum, track) => sum + track.notes.length, 0);
                const estimatedChunks = Math.ceil(totalNotes / chunkNoteCount);
                const fps = parseInt(this.flashFPS.value);

                const info = `
ファイル: ${this.midiFile.files[0].name}
演奏時間: ${this.originalMidi.duration.toFixed(1)}秒
音符数: ${totalNotes}
予想チャンク数: ${estimatedChunks}
転送予想時間: ${(estimatedChunks / fps).toFixed(1)}秒
                `.trim();

                this.senderMidiInfo.textContent = info;
            }

            generateQRCodes() {
                if (!this.originalMidi) return;

                const chunkNoteCount = parseInt(this.chunkNoteCount.value);
                this.qrChunks = [];

                const chunks = this.splitMidiByNoteCount(this.originalMidi, chunkNoteCount);

                chunks.forEach((chunk, index) => {
                    const compressedData = this.compressChunkData(chunk, index, chunks.length);
                    const qrData = 'M:' + JSON.stringify(compressedData);
                    this.qrChunks.push(qrData);
                });

                this.currentChunkIndex = 0;
                this.flashBtn.disabled = false;
                this.updateSenderStatus(`${this.qrChunks.length}個のQRコード生成完了`, 'success');
                this.updateProgressDisplay();
                this.updateDataSizeDisplay();

                if (this.qrChunks.length > 0) {
                    this.displayQRCode(this.qrChunks[0]);
                }
            }

            // 超圧縮データ作成
            compressChunkData(chunk, index, total) {
                const compressed = [
                    index, // チャンクインデックス
                    total, // 総チャンク数
                    Math.round(chunk.tempo || 120), // テンポ
                    Math.round(chunk.startTime * 1000), // 開始時間(ms)
                    Math.round(chunk.endTime * 1000), // 終了時間(ms)
                ];

                // タイムグループを圧縮
                chunk.timeGroups.forEach(timeGroup => {
                    compressed.push(Math.round(timeGroup.time * 1000)); // 時間(ms)
                    compressed.push(timeGroup.notes.length); // 音符数

                    timeGroup.notes.forEach(note => {
                        compressed.push(this.noteNameToIndex(note.pitch)); // 音符番号
                        compressed.push(Math.round(note.duration * 1000)); // 持続時間(ms)
                        compressed.push(Math.round(note.velocity * 127)); // ベロシティ(0-127)
                    });
                });

                return compressed;
            }

            // 音符名を番号に変換
            noteNameToIndex(noteName) {
                const noteMap = { 'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11 };
                const match = noteName.match(/([A-G]#?)(-?\d+)/);
                if (!match) return 60; // C4をデフォルト

                const note = match[1];
                const octave = parseInt(match[2]);
                return (octave + 1) * 12 + noteMap[note];
            }

            splitMidiByNoteCount(midi, maxNotesPerChunk) {
                // すべての音符を収集して時刻順にソート
                const allNotes = [];
                midi.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        allNotes.push({
                            pitch: note.name,
                            time: note.time,
                            duration: note.duration,
                            velocity: note.velocity || 0.8
                        });
                    });
                });

                allNotes.sort((a, b) => a.time - b.time);

                // 同時刻音符のグループ化
                const timeGroups = [];
                let currentTime = null;
                let currentGroup = null;
                const timeThreshold = 0.01;

                allNotes.forEach(note => {
                    const roundedTime = Math.round(note.time * 1000) / 1000;

                    if (currentTime === null || Math.abs(roundedTime - currentTime) > timeThreshold) {
                        if (currentGroup) {
                            timeGroups.push(currentGroup);
                        }
                        currentTime = roundedTime;
                        currentGroup = {
                            time: roundedTime,
                            notes: []
                        };
                    }

                    currentGroup.notes.push({
                        pitch: note.pitch,
                        duration: note.duration,
                        velocity: note.velocity
                    });
                });

                if (currentGroup) {
                    timeGroups.push(currentGroup);
                }

                // チャンクに分割
                const chunks = [];
                let currentChunk = null;
                let noteCount = 0;

                timeGroups.forEach(timeGroup => {
                    if (!currentChunk || noteCount + timeGroup.notes.length > maxNotesPerChunk) {
                        if (currentChunk) {
                            const lastGroup = currentChunk.timeGroups[currentChunk.timeGroups.length - 1];
                            const maxDuration = Math.max(...lastGroup.notes.map(n => n.duration || 0.5));
                            currentChunk.endTime = lastGroup.time + maxDuration;
                            chunks.push(currentChunk);
                        }

                        currentChunk = {
                            timeGroups: [],
                            startTime: timeGroup.time,
                            endTime: 0,
                            tempo: midi.header.tempos.length > 0 ? midi.header.tempos[0].bpm : 120
                        };
                        noteCount = 0;
                    }

                    currentChunk.timeGroups.push(timeGroup);
                    noteCount += timeGroup.notes.length;
                });

                if (currentChunk) {
                    const lastGroup = currentChunk.timeGroups[currentChunk.timeGroups.length - 1];
                    const maxDuration = Math.max(...lastGroup.notes.map(n => n.duration || 0.5));
                    currentChunk.endTime = lastGroup.time + maxDuration;
                    chunks.push(currentChunk);
                }

                return chunks;
            }

            displayQRCode(data) {
                try {
                    const qr = new QRious({
                        element: this.qrCanvas,
                        value: data,
                        size: 350,
                        background: 'white',
                        foreground: 'black',
                        level: 'M' // 中間レベルに統一
                    });
                } catch (error) {
                    this.updateSenderStatus('QRコード生成エラー: ' + error.message, 'error');
                }
            }

            startFlashing() {
                if (this.qrChunks.length === 0) return;

                const fps = parseInt(this.flashFPS.value);
                const interval = 1000 / fps;

                this.flashInterval = setInterval(() => {
                    this.displayQRCode(this.qrChunks[this.currentChunkIndex]);
                    this.currentChunkIndex = (this.currentChunkIndex + 1) % this.qrChunks.length;
                    this.updateProgressDisplay();
                }, interval);

                this.flashBtn.disabled = true;
                this.stopFlashBtn.disabled = false;
                this.updateSenderStatus(`${fps}FPSで送信中...`, 'success');
            }

            stopFlashing() {
                if (this.flashInterval) {
                    clearInterval(this.flashInterval);
                    this.flashInterval = null;
                }
                this.flashBtn.disabled = false;
                this.stopFlashBtn.disabled = true;
                this.updateSenderStatus('送信停止', 'info');
            }

            updateProgressDisplay() {
                this.progressDisplay.textContent = `${this.currentChunkIndex + 1} / ${this.qrChunks.length}`;
            }

            updateDataSizeDisplay() {
                if (this.qrChunks.length === 0) {
                    this.dataSizeDisplay.textContent = '0B';
                    return;
                }

                const totalSize = this.qrChunks.reduce((sum, qr) => sum + qr.length, 0);
                const avgSize = Math.round(totalSize / this.qrChunks.length);

                this.dataSizeDisplay.textContent = `平均${avgSize}B (総${totalSize}B)`;
            }

            updateSenderStatus(message, type) {
                this.senderStatus.textContent = message;
                this.senderStatus.className = `status ${type}`;
            }
        }

        // アプリケーション初期化
        document.addEventListener('DOMContentLoaded', () => {
            new MIDIQRStreaming();
        });
    </script>
</body>

</html>