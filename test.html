<!DOCTYPE html>
<!-- saved from url=(0057)https://ryusukeho.github.io/debug/test.html?v=334gqwr1234 -->
<html lang="ja" data-google-analytics-opt-out="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI QRã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚° - ã‚¿ã‚¤ãƒŸãƒ³ã‚°ä¿®æ­£ç‰ˆ</title>
    <script src="./MIDI QRã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚° - ã‚¿ã‚¤ãƒŸãƒ³ã‚°ä¿®æ­£ç‰ˆ_files/jsQR.js.ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"></script>
    <script src="./MIDI QRã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚° - ã‚¿ã‚¤ãƒŸãƒ³ã‚°ä¿®æ­£ç‰ˆ_files/qrious.min.js.ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"></script>
    <script src="./MIDI QRã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚° - ã‚¿ã‚¤ãƒŸãƒ³ã‚°ä¿®æ­£ç‰ˆ_files/Midi.js.ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"></script>
    <script src="./MIDI QRã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚° - ã‚¿ã‚¤ãƒŸãƒ³ã‚°ä¿®æ­£ç‰ˆ_files/Tone.js.ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h2 {
            margin-top: 0;
            color: #333;
        }

        video,
        canvas {
            width: 100%;
            max-width: 400px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }

        .controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        input[type="file"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 80px;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status.playing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.buffering {
            background: #e2e3e5;
            color: #383d41;
            border: 1px solid #d6d8db;
        }

        .flash-display {
            text-align: center;
            padding: 20px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qr-canvas {
            border: 2px solid #333;
            max-width: 100%;
        }

        .label {
            font-weight: bold;
            margin-right: 10px;
        }

        .midi-info {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }

        .timing-info {
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
        }

        .buffer-info {
            background: #f0f8e8;
            border: 1px solid #c6e5b3;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- å—ä¿¡ãƒ»å†ç”Ÿå´ -->
        <div class="panel">
            <h2>ğŸµ MIDIå—ä¿¡ãƒ»å†ç”Ÿ</h2>

            <video id="video" autoplay=""></video>
            <canvas id="canvas" style="display: none;"></canvas>

            <div class="controls">
                <button id="startBtn">ã‚«ãƒ¡ãƒ©é–‹å§‹</button>
                <button id="stopBtn" disabled="">åœæ­¢</button>
                <button id="clearBtn">ã‚¯ãƒªã‚¢</button>
                <button id="playBtn" disabled="">å†ç”Ÿ</button>
                <button id="stopPlayBtn" disabled="">åœæ­¢</button>
            </div>

            <div class="controls">
                <span class="label">ãƒãƒƒãƒ•ã‚¡æ™‚é–“:</span>
                <input type="number" id="bufferDuration" value="3" min="1" max="10" step="1">
                <span>ç§’</span>
                <label>
                    <input type="checkbox" id="autoPlay" checked="">
                    è‡ªå‹•å†ç”Ÿ
                </label>
                <label>
                    <input type="checkbox" id="debugMode">
                    ãƒ‡ãƒãƒƒã‚°
                </label>
            </div>

            <div id="receiverStatus" class="status info">ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„</div>

            <div class="progress-bar">
                <div id="receivedProgress" class="progress-fill" style="background: #bee5eb; z-index: 1;"></div>
                <div id="playProgress" class="progress-fill"
                    style="background: #007bff; z-index: 2; position: absolute; top: 0;"></div>
            </div>

            <div class="buffer-info" id="bufferInfo">
                ãƒãƒƒãƒ•ã‚¡æƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...
            </div>

            <div class="timing-info" id="timingInfo">
                ã‚¿ã‚¤ãƒŸãƒ³ã‚°æƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...
            </div>

            <div class="midi-info" id="midiInfo">
                MIDIãƒ‡ãƒ¼ã‚¿ã®å—ä¿¡ã‚’å¾…ã£ã¦ã„ã¾ã™...
            </div>
        </div>

        <!-- é€ä¿¡å´ -->
        <div class="panel">
            <h2>ğŸ“¤ MIDIé€ä¿¡</h2>

            <div class="controls">
                <input type="file" id="midiFile" accept=".mid,.midi">
                <button id="loadMidiBtn">MIDIèª­ã¿è¾¼ã¿</button>
            </div>

            <div class="controls">
                <span class="label">ãƒãƒ£ãƒ³ã‚¯éŸ³ç¬¦æ•°:</span>
                <input type="number" id="chunkNoteCount" value="15" min="5" max="50" step="5">
                <span class="label">é€ä¿¡FPS:</span>
                <input type="number" id="flashFPS" value="8" min="1" max="20">
            </div>

            <div class="controls">
                <button id="generateBtn" disabled="">QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ</button>
                <button id="flashBtn" disabled="">ãƒ•ãƒ©ãƒƒã‚·ãƒ¥é–‹å§‹</button>
                <button id="stopFlashBtn" disabled="">ãƒ•ãƒ©ãƒƒã‚·ãƒ¥åœæ­¢</button>
            </div>

            <div id="senderStatus" class="status info">MIDIãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</div>

            <div class="flash-display">
                <canvas id="qrCanvas" class="qr-canvas"></canvas>
            </div>

            <div class="controls">
                <span class="label">é€²è¡ŒçŠ¶æ³:</span>
                <span id="progressDisplay">0 / 0</span>
            </div>

            <div class="midi-info" id="senderMidiInfo">
                MIDIãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...
            </div>
        </div>
    </div>

    <script>
        class MIDIQRStreaming {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.qrCanvas = document.getElementById('qrCanvas');

                // å—ä¿¡å´
                this.isScanning = false;
                this.receivedChunks = [];
                this.playedChunks = new Set();
                this.isPlaying = false;
                this.synth = null;
                this.playbackStartTime = null;
                this.currentPlaybackTime = 0;

                // ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°é–¢é€£
                this.isBuffering = false;
                this.bufferStartTime = null;
                this.scheduledNotes = [];
                this.playbackScheduler = null;

                // é€ä¿¡å´
                this.originalMidi = null;
                this.qrChunks = [];
                this.flashInterval = null;
                this.currentChunkIndex = 0;

                this.initializeElements();
                this.setupEventListeners();
            }

            initializeElements() {
                // å—ä¿¡å´
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.playBtn = document.getElementById('playBtn');
                this.stopPlayBtn = document.getElementById('stopPlayBtn');
                this.autoPlay = document.getElementById('autoPlay');
                this.debugMode = document.getElementById('debugMode');
                this.bufferDuration = document.getElementById('bufferDuration');
                this.receiverStatus = document.getElementById('receiverStatus');
                this.midiInfo = document.getElementById('midiInfo');
                this.timingInfo = document.getElementById('timingInfo');
                this.bufferInfo = document.getElementById('bufferInfo');
                this.receivedProgress = document.getElementById('receivedProgress');
                this.playProgress = document.getElementById('playProgress');

                // é€ä¿¡å´
                this.midiFile = document.getElementById('midiFile');
                this.loadMidiBtn = document.getElementById('loadMidiBtn');
                this.chunkNoteCount = document.getElementById('chunkNoteCount');
                this.flashFPS = document.getElementById('flashFPS');
                this.generateBtn = document.getElementById('generateBtn');
                this.flashBtn = document.getElementById('flashBtn');
                this.stopFlashBtn = document.getElementById('stopFlashBtn');
                this.senderStatus = document.getElementById('senderStatus');
                this.progressDisplay = document.getElementById('progressDisplay');
                this.senderMidiInfo = document.getElementById('senderMidiInfo');
            }

            setupEventListeners() {
                // å—ä¿¡å´
                this.startBtn.addEventListener('click', () => this.startCamera());
                this.stopBtn.addEventListener('click', () => this.stopCamera());
                this.clearBtn.addEventListener('click', () => this.clearData());
                this.playBtn.addEventListener('click', () => this.playMidi());
                this.stopPlayBtn.addEventListener('click', () => this.stopMidi());

                // é€ä¿¡å´
                this.loadMidiBtn.addEventListener('click', () => this.loadMidiFile());
                this.generateBtn.addEventListener('click', () => this.generateQRCodes());
                this.flashBtn.addEventListener('click', () => this.startFlashing());
                this.stopFlashBtn.addEventListener('click', () => this.stopFlashing());
            }

            async initializeAudio() {
                try {
                    await Tone.start();
                    this.synth = new Tone.PolySynth(Tone.Synth).toDestination();
                    console.log('Audio initialized');
                    return true;
                } catch (error) {
                    console.error('Audio init failed:', error);
                    return false;
                }
            }

            // ã‚«ãƒ¡ãƒ©é–¢é€£
            async startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' }
                    });
                    this.video.srcObject = stream;
                    this.video.addEventListener('loadedmetadata', () => {
                        this.canvas.width = this.video.videoWidth;
                        this.canvas.height = this.video.videoHeight;
                        this.startScanning();
                    });

                    this.startBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    this.updateReceiverStatus('ã‚«ãƒ¡ãƒ©é–‹å§‹', 'success');
                } catch (error) {
                    this.updateReceiverStatus('ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
            }

            stopCamera() {
                this.isScanning = false;
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                    this.video.srcObject = null;
                }
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.updateReceiverStatus('ã‚«ãƒ¡ãƒ©åœæ­¢', 'info');
            }

            startScanning() {
                this.isScanning = true;
                this.scanFrame();
            }

            scanFrame() {
                if (!this.isScanning) return;

                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);

                if (code) {
                    this.processQRCode(code.data);
                }

                requestAnimationFrame(() => this.scanFrame());
            }

            // QRã‚³ãƒ¼ãƒ‰å‡¦ç†
            processQRCode(data) {
                try {
                    if (data.startsWith('M:')) {
                        const compressedData = JSON.parse(data.substring(2));

                        const chunkData = {
                            index: compressedData.i,
                            total: compressedData.t,
                            tempo: compressedData.b,
                            startTime: compressedData.s,
                            endTime: compressedData.e,
                            duration: compressedData.d,
                            timeGroups: compressedData.g.map(group => ({
                                time: group.t,
                                notes: group.n.map(note => ({
                                    pitch: note.p,
                                    duration: note.d,
                                    velocity: note.v
                                }))
                            }))
                        };

                        // é‡è¤‡ãƒã‚§ãƒƒã‚¯
                        if (this.receivedChunks.some(c => c.index === chunkData.index)) {
                            return;
                        }

                        this.receivedChunks.push(chunkData);
                        this.receivedChunks.sort((a, b) => a.index - b.index);

                        const totalNotes = chunkData.timeGroups.reduce((sum, group) => sum + group.notes.length, 0);
                        this.updateReceiverStatus(
                            `ãƒãƒ£ãƒ³ã‚¯ ${chunkData.index + 1} å—ä¿¡ (${totalNotes}éŸ³ç¬¦, ${chunkData.duration.toFixed(2)}ç§’)`,
                            'success'
                        );

                        this.updateMidiInfo();
                        this.updateReceivedProgress();
                        this.updateBufferInfo();
                        this.tryAutoPlay();
                    }
                } catch (error) {
                    console.error('QRå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                }
            }

            updateMidiInfo() {
                if (this.receivedChunks.length === 0) return;

                const totalChunks = this.receivedChunks[0].total || this.receivedChunks.length;
                let info = `å—ä¿¡: ${this.receivedChunks.length} / ${totalChunks}\n\n`;

                this.receivedChunks.forEach(chunk => {
                    const played = this.playedChunks.has(chunk.index) ? 'âœ“' : 'â—‹';
                    const totalNotes = chunk.timeGroups.reduce((sum, group) => sum + group.notes.length, 0);
                    const timeGroups = chunk.timeGroups.length;
                    info += `${played} ãƒãƒ£ãƒ³ã‚¯${chunk.index + 1}: ${totalNotes}éŸ³ç¬¦(${timeGroups}ã‚°ãƒ«ãƒ¼ãƒ—) `;
                    info += `æ™‚é–“: ${chunk.startTime.toFixed(2)}s - ${chunk.endTime.toFixed(2)}s (${chunk.duration.toFixed(2)}s)\n`;
                });

                this.midiInfo.textContent = info;
            }

            updateBufferInfo() {
                if (this.receivedChunks.length === 0) {
                    this.bufferInfo.textContent = 'ãƒãƒƒãƒ•ã‚¡æƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...';
                    return;
                }

                const bufferTime = parseFloat(this.bufferDuration.value);
                const currentTime = this.isBuffering ?
                    (Date.now() - this.bufferStartTime) / 1000 : 0;

                let info = `=== ãƒãƒƒãƒ•ã‚¡çŠ¶æ…‹ ===\n`;
                info += `è¨­å®šãƒãƒƒãƒ•ã‚¡æ™‚é–“: ${bufferTime}ç§’\n`;

                if (this.isBuffering) {
                    info += `ç¾åœ¨ã®ãƒãƒƒãƒ•ã‚¡æ™‚é–“: ${currentTime.toFixed(1)}ç§’\n`;
                    info += `ãƒãƒƒãƒ•ã‚¡é€²æ—: ${Math.min(100, (currentTime / bufferTime) * 100).toFixed(1)}%\n`;
                } else if (this.isPlaying) {
                    info += `å†ç”Ÿä¸­: ${this.currentPlaybackTime.toFixed(2)}ç§’\n`;
                    info += `ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ¸ˆã¿éŸ³ç¬¦: ${this.scheduledNotes.length}\n`;
                } else {
                    info += `å¾…æ©Ÿä¸­\n`;
                }

                // ãƒãƒƒãƒ•ã‚¡å†…ã®ãƒãƒ£ãƒ³ã‚¯æƒ…å ±
                const bufferableChunks = this.receivedChunks.filter(chunk =>
                    chunk.startTime <= bufferTime
                );
                info += `ãƒãƒƒãƒ•ã‚¡å¯¾è±¡ãƒãƒ£ãƒ³ã‚¯: ${bufferableChunks.length}\n`;

                this.bufferInfo.textContent = info;
            }

            async tryAutoPlay() {
                if (!this.autoPlay.checked || this.isPlaying || this.isBuffering) {
                    return;
                }

                const bufferTime = parseFloat(this.bufferDuration.value);

                // ãƒãƒƒãƒ•ã‚¡æ™‚é–“å†…ã«ååˆ†ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const bufferableChunks = this.receivedChunks.filter(chunk =>
                    chunk.startTime < bufferTime
                );

                if (bufferableChunks.length > 0) {
                    await this.startBuffering();
                } else {
                    this.playBtn.disabled = false;
                }
            }

            // ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°æ©Ÿèƒ½
            async startBuffering() {
                if (this.isBuffering || this.isPlaying) return;

                this.isBuffering = true;
                this.bufferStartTime = Date.now();
                const bufferTime = parseFloat(this.bufferDuration.value);

                this.updateReceiverStatus(`ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ä¸­... (${bufferTime}ç§’)`, 'buffering');

                // ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã‚¿ã‚¤ãƒãƒ¼
                const bufferTimer = setInterval(() => {
                    const elapsed = (Date.now() - this.bufferStartTime) / 1000;
                    this.updateBufferInfo();

                    if (elapsed >= bufferTime) {
                        clearInterval(bufferTimer);
                        this.completeBuffering();
                    }
                }, 100);
            }

            async completeBuffering() {
                this.isBuffering = false;
                await this.playMidi();
            }

            // æ”¹è‰¯ã•ã‚ŒãŸå†ç”Ÿã‚·ã‚¹ãƒ†ãƒ 
            async playMidi() {
                if (this.receivedChunks.length === 0) return;

                if (!this.synth) {
                    const success = await this.initializeAudio();
                    if (!success) {
                        this.updateReceiverStatus('ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåˆæœŸåŒ–å¤±æ•—', 'error');
                        return;
                    }
                }

                this.isPlaying = true;
                this.playBtn.disabled = true;
                this.stopPlayBtn.disabled = false;
                this.playbackStartTime = Date.now();
                this.currentPlaybackTime = 0;
                this.scheduledNotes = [];

                // å…¨ãƒãƒ£ãƒ³ã‚¯ã‹ã‚‰éŸ³ç¬¦ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
                this.scheduleAllNotes();

                this.updateReceiverStatus('å†ç”Ÿä¸­...', 'playing');
                this.startPlaybackTimer();
            }

            scheduleAllNotes() {
                this.scheduledNotes = [];

                // å—ä¿¡æ¸ˆã¿ã®ã™ã¹ã¦ã®ãƒãƒ£ãƒ³ã‚¯ã‹ã‚‰éŸ³ç¬¦ã‚’æŠ½å‡º
                this.receivedChunks.forEach(chunk => {
                    chunk.timeGroups.forEach(timeGroup => {
                        timeGroup.notes.forEach(note => {
                            this.scheduledNotes.push({
                                time: timeGroup.time,
                                pitch: note.pitch,
                                duration: note.duration,
                                velocity: note.velocity,
                                chunkIndex: chunk.index,
                                played: false
                            });
                        });
                    });
                });

                // æ™‚é–“é †ã«ã‚½ãƒ¼ãƒˆ
                this.scheduledNotes.sort((a, b) => a.time - b.time);

                if (this.debugMode.checked) {
                    console.log(`${this.scheduledNotes.length} éŸ³ç¬¦ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«`);
                }
            }

            startPlaybackTimer() {
                this.playbackScheduler = setInterval(() => {
                    if (!this.isPlaying) return;

                    this.currentPlaybackTime = (Date.now() - this.playbackStartTime) / 1000;

                    // ç¾åœ¨æ™‚åˆ»ã§å†ç”Ÿã™ã¹ãéŸ³ç¬¦ã‚’æ¢ã™
                    const tolerance = 0.05; // 50msã®è¨±å®¹ç¯„å›²
                    const playableNotes = this.scheduledNotes.filter(note =>
                        !note.played &&
                        note.time <= this.currentPlaybackTime + tolerance &&
                        note.time >= this.currentPlaybackTime - tolerance
                    );

                    // éŸ³ç¬¦ã‚’å†ç”Ÿ
                    playableNotes.forEach(note => {
                        try {
                            this.synth.triggerAttackRelease(
                                note.pitch,
                                note.duration || 0.5,
                                undefined,
                                note.velocity || 0.8
                            );
                            note.played = true;

                            if (this.debugMode.checked && playableNotes.length > 0) {
                                console.log(`æ™‚åˆ» ${this.currentPlaybackTime.toFixed(3)}s: ${playableNotes.length}éŸ³ç¬¦å†ç”Ÿ`);
                            }
                        } catch (error) {
                            console.error('éŸ³ç¬¦å†ç”Ÿã‚¨ãƒ©ãƒ¼:', error, note);
                        }
                    });

                    // ãƒãƒ£ãƒ³ã‚¯ã®å†ç”ŸçŠ¶æ³ã‚’æ›´æ–°
                    this.updatePlayedChunks();
                    this.updateProgress();
                    this.updateBufferInfo();

                    // æ–°ã—ãå—ä¿¡ã—ãŸãƒãƒ£ãƒ³ã‚¯ãŒã‚ã‚Œã°è¿½åŠ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
                    this.addNewlyReceivedNotes();

                }, 20); // 20msé–“éš”ã§é«˜ç²¾åº¦ãƒã‚§ãƒƒã‚¯
            }

            addNewlyReceivedNotes() {
                // æ–°ã—ãå—ä¿¡ã—ãŸãƒãƒ£ãƒ³ã‚¯ã®éŸ³ç¬¦ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã«è¿½åŠ 
                const scheduledChunks = new Set(this.scheduledNotes.map(n => n.chunkIndex));

                this.receivedChunks.forEach(chunk => {
                    if (!scheduledChunks.has(chunk.index)) {
                        chunk.timeGroups.forEach(timeGroup => {
                            timeGroup.notes.forEach(note => {
                                // ã¾ã å†ç”Ÿæ™‚åˆ»ã‚’éãã¦ã„ãªã„éŸ³ç¬¦ã®ã¿è¿½åŠ 
                                if (timeGroup.time > this.currentPlaybackTime) {
                                    this.scheduledNotes.push({
                                        time: timeGroup.time,
                                        pitch: note.pitch,
                                        duration: note.duration,
                                        velocity: note.velocity,
                                        chunkIndex: chunk.index,
                                        played: false
                                    });
                                }
                            });
                        });
                        scheduledChunks.add(chunk.index);

                        if (this.debugMode.checked) {
                            console.log(`ãƒãƒ£ãƒ³ã‚¯ ${chunk.index + 1} ã®éŸ³ç¬¦ã‚’è¿½åŠ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«`);
                        }
                    }
                });

                // å†ã‚½ãƒ¼ãƒˆ
                this.scheduledNotes.sort((a, b) => a.time - b.time);
            }

            updatePlayedChunks() {
                this.receivedChunks.forEach(chunk => {
                    // ãƒãƒ£ãƒ³ã‚¯ã®çµ‚äº†æ™‚åˆ»ã‚’éããŸã‚‰ãƒ—ãƒ¬ã‚¤æ¸ˆã¿ã¨ãƒãƒ¼ã‚¯
                    if (this.currentPlaybackTime >= chunk.endTime && !this.playedChunks.has(chunk.index)) {
                        this.playedChunks.add(chunk.index);

                        if (this.debugMode.checked) {
                            console.log(`ãƒãƒ£ãƒ³ã‚¯ ${chunk.index + 1} å†ç”Ÿå®Œäº†`);
                        }
                    }
                });

                this.updateMidiInfo();
            }

            stopMidi() {
                this.isPlaying = false;
                this.isBuffering = false;
                this.playBtn.disabled = false;
                this.stopPlayBtn.disabled = true;

                if (this.playbackScheduler) {
                    clearInterval(this.playbackScheduler);
                    this.playbackScheduler = null;
                }

                if (this.synth) {
                    this.synth.releaseAll();
                }

                this.scheduledNotes = [];
                this.updateReceiverStatus('åœæ­¢', 'info');
                this.updateProgress(0);
                this.updateBufferInfo();
            }

            updateProgress(value = null) {
                if (value !== null) {
                    this.playProgress.style.width = `${value}%`;
                    return;
                }

                const total = this.receivedChunks[0]?.total || this.receivedChunks.length;
                const played = this.playedChunks.size;
                const percent = total > 0 ? (played / total) * 100 : 0;
                this.playProgress.style.width = `${percent}%`;
            }

            updateReceivedProgress() {
                if (this.receivedChunks.length === 0) {
                    this.receivedProgress.style.width = '0%';
                    return;
                }

                const total = this.receivedChunks[0].total;
                const received = this.receivedChunks.length;
                const percent = total > 0 ? (received / total) * 100 : 0;
                this.receivedProgress.style.width = `${percent}%`;
            }

            clearData() {
                this.receivedChunks = [];
                this.playedChunks.clear();
                this.scheduledNotes = [];
                this.stopMidi();
                this.midiInfo.textContent = 'MIDIãƒ‡ãƒ¼ã‚¿ã®å—ä¿¡ã‚’å¾…ã£ã¦ã„ã¾ã™...';
                this.bufferInfo.textContent = 'ãƒãƒƒãƒ•ã‚¡æƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...';
                this.updateReceivedProgress();
                this.updateReceiverStatus('ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢', 'info');
            }

            updateReceiverStatus(message, type) {
                this.receiverStatus.textContent = message;
                this.receiverStatus.className = `status ${type}`;
            }

            // é€ä¿¡å´ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¤‰æ›´ãªã—ï¼‰
            async loadMidiFile() {
                const file = this.midiFile.files[0];
                if (!file) {
                    this.updateSenderStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                    return;
                }

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.originalMidi = new Midi(arrayBuffer);

                    this.displayMidiInfo();
                    this.generateBtn.disabled = false;
                    this.updateSenderStatus('MIDIèª­ã¿è¾¼ã¿å®Œäº†', 'success');
                } catch (error) {
                    this.updateSenderStatus('èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
            }

            displayMidiInfo() {
                if (!this.originalMidi) return;

                const chunkNoteCount = parseInt(this.chunkNoteCount.value);
                const totalNotes = this.originalMidi.tracks.reduce((sum, track) => sum + track.notes.length, 0);
                const estimatedChunks = Math.ceil(totalNotes / chunkNoteCount);
                const fps = parseInt(this.flashFPS.value);

                const uniqueTimes = new Set();
                this.originalMidi.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        uniqueTimes.add(Math.round(note.time * 1000) / 1000);
                    });
                });

                const info = `
ãƒ•ã‚¡ã‚¤ãƒ«: ${this.midiFile.files[0].name}
æ¼”å¥æ™‚é–“: ${this.originalMidi.duration.toFixed(1)}ç§’
éŸ³ç¬¦æ•°: ${totalNotes}
ãƒ¦ãƒ‹ãƒ¼ã‚¯æ™‚åˆ»: ${uniqueTimes.size}
äºˆæƒ³ãƒãƒ£ãƒ³ã‚¯æ•°: ${estimatedChunks}
è»¢é€äºˆæƒ³æ™‚é–“: ${(estimatedChunks / fps).toFixed(1)}ç§’
                `.trim();

                this.senderMidiInfo.textContent = info;
            }

            generateQRCodes() {
                if (!this.originalMidi) return;

                const chunkNoteCount = parseInt(this.chunkNoteCount.value);
                this.qrChunks = [];

                const chunks = this.splitMidiByNoteCountWithTiming(this.originalMidi, chunkNoteCount);

                chunks.forEach((chunk, index) => {
                    const chunkData = {
                        i: index,
                        t: chunks.length,
                        b: chunk.tempo || 120,
                        s: chunk.startTime,
                        e: chunk.endTime,
                        d: chunk.duration,
                        g: chunk.timeGroups.map(group => ({
                            t: group.time,
                            n: group.notes.map(note => ({
                                p: note.pitch,
                                d: note.duration,
                                v: note.velocity || 0.8
                            }))
                        }))
                    };

                    const qrData = 'M:' + JSON.stringify(chunkData);
                    this.qrChunks.push(qrData);
                });

                this.currentChunkIndex = 0;
                this.flashBtn.disabled = false;
                this.updateSenderStatus(`${this.qrChunks.length}å€‹ã®QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆå®Œäº†`, 'success');
                this.updateProgressDisplay();

                if (this.qrChunks.length > 0) {
                    this.displayQRCode(this.qrChunks[0]);
                }
            }

            splitMidiByNoteCountWithTiming(midi, maxNotesPerChunk) {
                // ã™ã¹ã¦ã®éŸ³ç¬¦ã‚’åé›†ã—ã¦æ™‚åˆ»é †ã«ã‚½ãƒ¼ãƒˆ
                const allNotes = [];
                midi.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        allNotes.push({
                            pitch: note.name,
                            time: note.time,
                            duration: note.duration,
                            velocity: note.velocity || 0.8
                        });
                    });
                });

                allNotes.sort((a, b) => a.time - b.time);

                // åŒæ™‚åˆ»éŸ³ç¬¦ã®ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼ˆç²¾åº¦å‘ä¸Šï¼‰
                const timeGroups = [];
                let currentTime = null;
                let currentGroup = null;
                const timeThreshold = 0.01; // 10msã®åŒæ™‚åˆ»åˆ¤å®š

                allNotes.forEach(note => {
                    const roundedTime = Math.round(note.time * 1000) / 1000;

                    if (currentTime === null || Math.abs(roundedTime - currentTime) > timeThreshold) {
                        if (currentGroup) {
                            timeGroups.push(currentGroup);
                        }
                        currentTime = roundedTime;
                        currentGroup = {
                            time: roundedTime,
                            notes: []
                        };
                    }

                    currentGroup.notes.push({
                        pitch: note.pitch,
                        duration: note.duration,
                        velocity: note.velocity
                    });
                });

                if (currentGroup) {
                    timeGroups.push(currentGroup);
                }

                // ãƒãƒ£ãƒ³ã‚¯ã«åˆ†å‰²ï¼ˆæ™‚é–“æƒ…å ±ä»˜ãï¼‰
                const chunks = [];
                let currentChunk = null;
                let noteCount = 0;

                timeGroups.forEach(timeGroup => {
                    // æ–°ã—ã„ãƒãƒ£ãƒ³ã‚¯ãŒå¿…è¦ã‹åˆ¤å®š
                    if (!currentChunk || noteCount + timeGroup.notes.length > maxNotesPerChunk) {
                        if (currentChunk) {
                            // å‰ã®ãƒãƒ£ãƒ³ã‚¯ã®çµ‚äº†æ™‚é–“ã‚’è¨ˆç®—
                            const lastGroup = currentChunk.timeGroups[currentChunk.timeGroups.length - 1];
                            const maxDuration = Math.max(...lastGroup.notes.map(n => n.duration || 0.5));
                            currentChunk.endTime = lastGroup.time + maxDuration;
                            currentChunk.duration = currentChunk.endTime - currentChunk.startTime;
                            chunks.push(currentChunk);
                        }

                        currentChunk = {
                            timeGroups: [],
                            startTime: timeGroup.time,
                            endTime: 0,
                            duration: 0,
                            tempo: midi.header.tempos.length > 0 ? midi.header.tempos[0].bpm : 120
                        };
                        noteCount = 0;
                    }

                    currentChunk.timeGroups.push(timeGroup);
                    noteCount += timeGroup.notes.length;
                });

                // æœ€å¾Œã®ãƒãƒ£ãƒ³ã‚¯ã‚’å‡¦ç†
                if (currentChunk) {
                    const lastGroup = currentChunk.timeGroups[currentChunk.timeGroups.length - 1];
                    const maxDuration = Math.max(...lastGroup.notes.map(n => n.duration || 0.5));
                    currentChunk.endTime = lastGroup.time + maxDuration;
                    currentChunk.duration = currentChunk.endTime - currentChunk.startTime;
                    chunks.push(currentChunk);
                }

                return chunks;
            }

            displayQRCode(data) {
                try {
                    const dataLength = data.length;
                    let level = 'H';
                    let size = 350;

                    if (dataLength < 200) {
                        level = 'H';
                        size = 400;
                    } else if (dataLength < 400) {
                        level = 'Q';
                        size = 380;
                    } else if (dataLength < 600) {
                        level = 'M';
                        size = 350;
                    } else {
                        level = 'L';
                        size = 320;
                    }

                    const qr = new QRious({
                        element: this.qrCanvas,
                        value: data,
                        size: size,
                        background: 'white',
                        foreground: 'black',
                        level: level
                    });

                    if (this.currentChunkIndex === 0) {
                        this.updateSenderStatus(
                            `é€ä¿¡ä¸­ (${dataLength}æ–‡å­—, ${level}ãƒ¬ãƒ™ãƒ«, ${size}px)`,
                            'success'
                        );
                    }
                } catch (error) {
                    this.updateSenderStatus('QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
            }

            startFlashing() {
                if (this.qrChunks.length === 0) return;

                const fps = parseInt(this.flashFPS.value);
                const interval = 1000 / fps;

                this.flashInterval = setInterval(() => {
                    this.displayQRCode(this.qrChunks[this.currentChunkIndex]);
                    this.currentChunkIndex = (this.currentChunkIndex + 1) % this.qrChunks.length;
                    this.updateProgressDisplay();
                }, interval);

                this.flashBtn.disabled = true;
                this.stopFlashBtn.disabled = false;
                this.updateSenderStatus(`${fps}FPSã§é€ä¿¡ä¸­...`, 'success');
            }

            stopFlashing() {
                if (this.flashInterval) {
                    clearInterval(this.flashInterval);
                    this.flashInterval = null;
                }
                this.flashBtn.disabled = false;
                this.stopFlashBtn.disabled = true;
                this.updateSenderStatus('é€ä¿¡åœæ­¢', 'info');
            }

            updateProgressDisplay() {
                this.progressDisplay.textContent = `${this.currentChunkIndex + 1} / ${this.qrChunks.length}`;
            }

            updateSenderStatus(message, type) {
                this.senderStatus.textContent = message;
                this.senderStatus.className = `status ${type}`;
            }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            new MIDIQRStreaming();
        });
    </script>


</body>

</html>