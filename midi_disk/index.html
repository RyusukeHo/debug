<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Disk Scanner - Hyomon Tech</title>
    <style>
        body {
            background-color: rgb(42, 43, 71);
            color: rgb(209, 213, 233);
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }

        .container {
            display: flex;
            gap: 30px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .disk-display {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .scanner {
            flex: 1;
            min-width: 300px;
        }

        .disk-container {
            position: relative;
            margin-top: 50px;
        }

        #diskCanvas {
            border: 2px solid rgb(100, 100, 130);
        }

        .node-generator {
            width: 20px;
            height: 150px;
            background: rgb(209, 213, 233);
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            background-color: rgb(72, 73, 101);
            color: rgb(209, 213, 233);
            border: 1px solid rgb(100, 100, 130);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background-color: rgb(92, 93, 121);
        }

        button:active {
            transform: translateY(1px);
        }

        input,
        select {
            background-color: rgb(72, 73, 101);
            color: rgb(209, 213, 233);
            border: 1px solid rgb(100, 100, 130);
            padding: 8px;
            border-radius: 4px;
        }

        #video {
            border: 2px solid rgb(100, 100, 130);
            max-width: 100%;
            border-radius: 8px;
        }

        #debugCanvas {
            border: 2px solid rgb(100, 100, 130);
            max-width: 100%;
            margin: 5px 0;
        }

        .output {
            background-color: rgb(72, 73, 101);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 14px;
        }

        .status.success {
            background-color: rgba(72, 187, 120, 0.3);
            border: 1px solid rgba(72, 187, 120, 0.5);
        }

        .status.error {
            background-color: rgba(245, 101, 101, 0.3);
            border: 1px solid rgba(245, 101, 101, 0.5);
        }

        .status.info {
            background-color: rgba(66, 153, 225, 0.3);
            border: 1px solid rgba(66, 153, 225, 0.5);
        }

        .section {
            background-color: rgba(100, 100, 130, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .debug-info {
            font-size: 11px;
            color: rgba(209, 213, 233, 0.7);
        }

        .scan-point {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>

<body>
    <h1>MIDI Disk Scanner - Hyomon Tech</h1>

    <div class="container">
        <!-- Original MIDI Disk Display -->
        <div class="disk-display">
            <h2>MIDI Disk</h2>
            <div class="controls">
                <input type="text" id="dataInput" placeholder="Enter text to encode" value="Hello Hyomon Tech!">
                <button onclick="updateDiskData()">Update Data</button>
                <button onclick="toggleRotation()">Play/Pause</button>
            </div>
            <div class="disk-container">
                <canvas id="diskCanvas" width="400" height="400"></canvas>
                <div class="node-generator"></div>
            </div>
            <div class="output" id="diskInfo"></div>
        </div>

        <!-- Scanner -->
        <div class="scanner">
            <h2>Real-time Scanner</h2>
            <div class="section">
                <h3>Camera Controls</h3>
                <div class="controls">
                    <button onclick="startCamera()">Start Camera</button>
                    <button onclick="stopCamera()">Stop Camera</button>
                    <button onclick="toggleDebugMode()">Toggle Debug</button>
                    <select id="deviceSelect"></select>
                </div>
                <video id="video" width="400" height="300" autoplay muted></video>
                <canvas id="debugCanvas" width="400" height="400"></canvas>
                <div class="scan-point" id="scanPoint" style="display: none;"></div>
                <div id="scanStatus" class="status info">Camera not started</div>
                <div id="debugInfo" class="debug-info"></div>
            </div>

            <div class="section">
                <h3>Scanned Data</h3>
                <div class="output" id="scannedData">Point camera at the rotating disk to scan...</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let stream = null;
        let scanInterval = null;
        let animationId = null;
        let isRotating = true;
        let debugMode = true;
        let scanHistory = [];
        let lastScanTime = 0;

        const video = document.getElementById('video');
        const debugCanvas = document.getElementById('debugCanvas');
        const debugCtx = debugCanvas.getContext('2d');

        // Original MIDI disk parameters
        const diskCanvas = document.getElementById('diskCanvas');
        const diskCtx = diskCanvas.getContext('2d');
        const centerX = diskCanvas.width / 2;
        const centerY = diskCanvas.height / 2;
        const diskRadius = 200;
        const holeRadius = 50;
        const numTracks = 10;
        const trackWidth = (diskRadius - holeRadius) / numTracks;
        const rotationSpeed = 0.05;

        let currentRotation = 0;
        let latestProcessedArcIndex = -1;
        let arcs = {};
        let plannedArc = [];
        let currentData = "Hello Hyomon Tech!";

        // QR„Ç≥„Éº„ÉâÈ¢®„Éï„Ç°„Ç§„É≥„ÉÄ„Éº„Éë„Çø„Éº„É≥„ÅÆÊúüÂæÖÂ∫ßÊ®ôÔºà„Éá„Ç£„Çπ„ÇØ‰∏ä„ÅÆÁõ∏ÂØæ‰ΩçÁΩÆÔºâ
        const expectedFinderPositions = [
            { x: 0.07, y: 0.07, id: 'TL' },      // Top-left (4% from edges)
            { x: 0.93, y: 0.07, id: 'TR' },     // Top-right
            { x: 0.07, y: 0.93, id: 'BL' },     // Bottom-left
        ];

        function drawFinderPattern(ctx, x, y, size) {
            // QR„Ç≥„Éº„ÉâÈ¢®„ÅÆ‰ΩçÁΩÆÊ±∫„ÇÅ„Éû„Éº„Ç´„Éº
            const s = size / 2;

            // Â§ñÂÅ¥„ÅÆÁôΩ„ÅÑÊ≠£ÊñπÂΩ¢
            ctx.fillStyle = 'white';
            ctx.fillRect(x - s - 1, y - s - 1, size + 2, size + 2);

            // Â§ñÂÅ¥„ÅÆÈªí„ÅÑÊ≠£ÊñπÂΩ¢
            ctx.fillStyle = 'black';
            ctx.fillRect(x - s, y - s, size, size);

            // ÂÜÖÂÅ¥„ÅÆÁôΩ„ÅÑÊ≠£ÊñπÂΩ¢
            ctx.fillStyle = 'white';
            ctx.fillRect(x - s + 3, y - s + 3, size - 6, size - 6);

            // ‰∏≠Â§Æ„ÅÆÈªí„ÅÑÊ≠£ÊñπÂΩ¢
            ctx.fillStyle = 'black';
            const innerSize = size * 0.35;
            ctx.fillRect(x - innerSize / 2, y - innerSize / 2, innerSize, innerSize);
        }

        function drawDisk() {
            // Èªí„ÅÑÂÜÜÁõ§„ÇíÊèèÁîª
            diskCtx.fillStyle = 'black';
            diskCtx.beginPath();
            diskCtx.arc(centerX, centerY, diskRadius, 0, Math.PI * 2);
            diskCtx.fill();

            // ÂÜÖÂÅ¥„ÅÆÁ©¥„ÇíÊèèÁîª
            diskCtx.fillStyle = 'rgb(42, 43, 71)';
            diskCtx.beginPath();
            diskCtx.arc(centerX, centerY, holeRadius, 0, Math.PI * 2);
            diskCtx.fill();

            // QR„Ç≥„Éº„ÉâÈ¢®„ÅÆ‰ΩçÁΩÆÊ±∫„ÇÅ„Éû„Éº„Ç´„ÉºÔºàÂõõÈöÖ„ÅÆÂõ∫ÂÆö‰ΩçÁΩÆÔºâ
            expectedFinderPositions.forEach(pos => {
                const x = pos.x * diskCanvas.width;
                const y = pos.y * diskCanvas.height;
                drawFinderPattern(diskCtx, x, y, 50);
            });
        }

        function drawArcsOnTrack(arcIndex) {
            const arcData = arcs[arcIndex];
            const innerRadius = holeRadius + arcData.track * trackWidth + 2;
            const outerRadius = holeRadius + (arcData.track + 1) * trackWidth - 2;
            const midRadius = (innerRadius + outerRadius) / 2;

            const arcLength = arcData.length;
            const startAngle = arcData.pos;
            const endAngle = startAngle - arcLength;

            // ÁôΩ„ÅÑÂºß„ÇíÊèèÁîª
            diskCtx.strokeStyle = 'white';
            diskCtx.lineWidth = trackWidth * 0.8;
            diskCtx.lineCap = 'butt';
            diskCtx.beginPath();
            diskCtx.arc(centerX, centerY, midRadius, endAngle, startAngle);
            diskCtx.stroke();
        }

        function clearCanvas() {
            diskCtx.clearRect(0, 0, diskCanvas.width, diskCanvas.height);
        }

        function animate() {
            if (!isRotating) {
                animationId = requestAnimationFrame(animate);
                return;
            }

            clearCanvas();
            drawDisk();
            currentRotation += rotationSpeed;

            for (let index = latestProcessedArcIndex + 1; index < plannedArc.length; index++) {
                const element = plannedArc[index];
                if (element.timing < currentRotation) {
                    latestProcessedArcIndex = index;
                    createArc(element.track, Math.PI * (2 + 0.5), element.length);
                } else {
                    break;
                }
            }

            for (const arc in arcs) {
                arcs[arc].pos -= rotationSpeed;
                arcs[arc].length = Math.min(arcs[arc].pos - Math.PI * 0.5, arcs[arc].length);
                if (arcs[arc].pos <= Math.PI * 0.5) {
                    delete arcs[arc];
                } else {
                    drawArcsOnTrack(arc);
                }
            }

            if (latestProcessedArcIndex == plannedArc.length - 1) {
                latestProcessedArcIndex = -1;
                currentRotation = 0;
            }

            animationId = requestAnimationFrame(animate);
        }

        function createArc(track, pos, length) {
            arcs[crypto.randomUUID()] = {
                track: track,
                pos: pos,
                length: length
            };
        }

        function bitsToPlannedArcMultiLevel(bitString, segments = 24) {
            const plannedArc = [];
            const arcLength = (Math.PI * 2 / segments);
            let bitIndex = 0;

            while (bitIndex < bitString.length) {
                const timing = Math.PI * 0.5 + (bitIndex / numTracks) * arcLength;
                for (let t = 0; t < numTracks; t++) {
                    if (bitIndex >= bitString.length) break;

                    if (bitString[bitIndex] === '1') {
                        plannedArc.push({
                            timing: timing,
                            length: arcLength * 0.9,
                            track: t
                        });
                    }
                    bitIndex++;
                }
            }
            return plannedArc;
        }

        function stringToBitString(str) {
            let bitString = '';
            for (let i = 0; i < str.length; i++) {
                const ascii = str.charCodeAt(i);
                const bits = ascii.toString(2).padStart(8, '0');
                bitString += bits;
            }
            return bitString;
        }

        function bitStringToString(bitString) {
            let result = '';
            for (let i = 0; i < bitString.length; i += 8) {
                const byte = bitString.substr(i, 8);
                if (byte.length === 8) {
                    const ascii = parseInt(byte, 2);
                    if (ascii > 0 && ascii < 128) { // Valid ASCII range
                        result += String.fromCharCode(ascii);
                    }
                }
            }
            return result;
        }

        function updateDiskData() {
            currentData = document.getElementById('dataInput').value;
            const bitString = stringToBitString(currentData);
            plannedArc = bitsToPlannedArcMultiLevel(bitString + "                                                  ");
            latestProcessedArcIndex = -1;
            currentRotation = 0;
            arcs = {};

            document.getElementById('diskInfo').textContent =
                `Data: "${currentData}"\nBinary: ${bitString}\nBits: ${bitString.length}\nTracks: ${numTracks}`;
        }

        function toggleRotation() {
            isRotating = !isRotating;
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            debugCanvas.style.display = debugMode ? 'block' : 'none';
            document.getElementById('scanPoint').style.display = debugMode ? 'block' : 'none';
        }

        // === ËªΩÈáèÂåñ„Åï„Çå„Åü„Ç≥„É≥„Éî„É•„Éº„Çø„Éì„Ç∏„Éß„É≥ÂÆüË£Ö ===

        function findFinderPatterns(imageData, width, height) {
            // È´òÁ≤æÂ∫¶„Éï„Ç°„Ç§„É≥„ÉÄ„Éº„Éë„Çø„Éº„É≥Ê§úÂá∫Ôºà3„Å§ÂâçÊèêÔºâ
            const patterns = [];
            const step = 10; // „Çà„ÇäÁ¥∞„Åã„Åè„Çπ„Ç≠„É£„É≥
            const targetSize = 50; // Âõ∫ÂÆö„Çµ„Ç§„Ç∫„ÅßÊ§úÂá∫
            const sizeVariance = 10; // ¬±10„Éî„ÇØ„Çª„É´„ÅÆË®±ÂÆπÁØÑÂõ≤

            for (let y = 0; y < height - targetSize - sizeVariance; y += step) {
                for (let x = 0; x < width - targetSize - sizeVariance; x += step) {
                    for (let size = targetSize - sizeVariance; size <= targetSize + sizeVariance; size += 5) {
                        const score = calculateFinderPatternScore(imageData, width, height, x, y, size);
                        if (score > 0.85) { // È´ò„ÅÑÈñæÂÄ§„ÅßË™§Ê§úÂá∫„ÇíÈò≤„Åê
                            patterns.push({
                                x: x + size / 2,
                                y: y + size / 2,
                                size,
                                score: score,
                                contrast: calculateContrast(imageData, width, height, x, y, size)
                            });
                        }
                    }
                }
            }

            // „Çπ„Ç≥„Ç¢„Å®„Ç≥„É≥„Éà„É©„Çπ„Éà„Åß„ÇΩ„Éº„Éà
            patterns.sort((a, b) => (b.score * b.contrast) - (a.score * a.contrast));

            // ÈáçË§áÈô§ÂéªÔºà„Çà„ÇäÂé≥Ê†º„Å™Ë∑ùÈõ¢„ÉÅ„Çß„ÉÉ„ÇØÔºâ
            const filtered = [];
            for (const pattern of patterns) {
                let isDuplicate = false;
                for (const existing of filtered) {
                    const dist = Math.sqrt((pattern.x - existing.x) ** 2 + (pattern.y - existing.y) ** 2);
                    if (dist < pattern.size * 0.6) { // „Çà„ÇäÂé≥Ê†º„Å™ÈáçË§áÂà§ÂÆö
                        isDuplicate = true;
                        break;
                    }
                }
                if (!isDuplicate && filtered.length < 3) { // 3„Å§„Åæ„Åß„Å´Âà∂Èôê
                    filtered.push(pattern);
                }
            }

            return filtered;
        }

        function calculateFinderPatternScore(imageData, width, height, x, y, size) {
            // „Çà„ÇäÊ≠£Á¢∫„Å™7x7„Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ„É≥„Ç∞
            const cellSize = size / 7;
            const expected = [
                [1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1]
            ];

            let correctMatches = 0;
            let totalChecked = 0;
            let centerContrast = 0;

            for (let py = 0; py < 7; py++) {
                for (let px = 0; px < 7; px++) {
                    const centerX = Math.floor(x + px * cellSize + cellSize / 2);
                    const centerY = Math.floor(y + py * cellSize + cellSize / 2);

                    if (centerX >= 0 && centerX < width && centerY >= 0 && centerY < height) {
                        // ÂêÑ„Çª„É´„ÅÆÂπ≥ÂùáÊòéÂ∫¶„ÇíË®àÁÆóÔºà„Éé„Ç§„Ç∫ËÄêÊÄßÂêë‰∏äÔºâ
                        let avgGray = 0;
                        let sampleCount = 0;

                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const sampleX = centerX + dx;
                                const sampleY = centerY + dy;
                                if (sampleX >= 0 && sampleX < width && sampleY >= 0 && sampleY < height) {
                                    const idx = (sampleY * width + sampleX) * 4;
                                    avgGray += imageData[idx] * 0.299 + imageData[idx + 1] * 0.587 + imageData[idx + 2] * 0.114;
                                    sampleCount++;
                                }
                            }
                        }

                        if (sampleCount > 0) {
                            avgGray /= sampleCount;
                            const isBlack = avgGray < 120; // „Çà„ÇäÂé≥Ê†º„Å™ÈñæÂÄ§
                            const expectedBlack = expected[py][px] === 1;

                            if (isBlack === expectedBlack) {
                                correctMatches++;
                            }

                            // ‰∏≠Â§ÆÈÉ®ÂàÜÔºà3,3Ôºâ„ÅÆ„Ç≥„É≥„Éà„É©„Çπ„Éà„ÇíÊ∏¨ÂÆö
                            if (px === 3 && py === 3) {
                                centerContrast = isBlack ? avgGray : (255 - avgGray);
                            }

                            totalChecked++;
                        }
                    }
                }
            }

            if (totalChecked === 0) return 0;

            const patternScore = correctMatches / totalChecked;
            const contrastBonus = Math.min(1.0, centerContrast / 100); // „Ç≥„É≥„Éà„É©„Çπ„Éà„Éú„Éº„Éä„Çπ

            return patternScore * (0.8 + 0.2 * contrastBonus); // „Éë„Çø„Éº„É≥80% + „Ç≥„É≥„Éà„É©„Çπ„Éà20%
        }

        function calculateContrast(imageData, width, height, x, y, size) {
            // „Éë„Çø„Éº„É≥ÂÜÖ„ÅÆ„Ç≥„É≥„Éà„É©„Çπ„Éà„ÇíË®àÁÆóÔºàË™§Ê§úÂá∫Èò≤Ê≠¢Ôºâ
            let minBrightness = 255;
            let maxBrightness = 0;
            let sampleCount = 0;

            for (let dy = 0; dy < size; dy += 3) {
                for (let dx = 0; dx < size; dx += 3) {
                    const px = x + dx;
                    const py = y + dy;

                    if (px >= 0 && px < width && py >= 0 && py < height) {
                        const idx = (py * width + px) * 4;
                        const gray = imageData[idx] * 0.299 + imageData[idx + 1] * 0.587 + imageData[idx + 2] * 0.114;

                        minBrightness = Math.min(minBrightness, gray);
                        maxBrightness = Math.max(maxBrightness, gray);
                        sampleCount++;
                    }
                }
            }

            return sampleCount > 0 ? (maxBrightness - minBrightness) / 255 : 0;
        }

        function extractDiskBounds(finderPatterns) {
            // 3„Å§‰ª•‰∏ä„ÅÆ„Éï„Ç°„Ç§„É≥„ÉÄ„Éº„Éë„Çø„Éº„É≥„Åã„Çâ„Éá„Ç£„Çπ„ÇØ„ÅÆÂ¢ÉÁïå„ÇíË®àÁÆó
            if (finderPatterns.length < 3) return null;

            // „Éë„Çø„Éº„É≥„ÅÆ‰ΩçÁΩÆ„Åã„ÇâÂõõËßíÂΩ¢„ÅÆÂ¢ÉÁïå„ÇíÊé®ÂÆö
            const xs = finderPatterns.map(p => p.x);
            const ys = finderPatterns.map(p => p.y);

            const minX = Math.min(...xs) - 50;
            const maxX = Math.max(...xs) + 50;
            const minY = Math.min(...ys) - 50;
            const maxY = Math.max(...ys) + 50;

            return { minX, maxX, minY, maxY, width: maxX - minX, height: maxY - minY };
        }

        function scanSinglePoint(imageData, width, height, bounds) {
            // „Éá„Ç£„Çπ„ÇØÁØÑÂõ≤ÂÜÖ„ÅÆ‰∏≠Â§Æ‰ªòËøë„Åß‰∏ÄÁÇπ„Çπ„Ç≠„É£„É≥
            if (!bounds) return null;

            const centerX = bounds.minX + bounds.width / 2;
            const centerY = bounds.minY + bounds.height / 2;

            // ‰∏≠Â§Æ„Åã„ÇâÂ∞ë„ÅóÂè≥„Å´„Åö„Çâ„Åó„Åü‰ΩçÁΩÆ„Åß„Çπ„Ç≠„É£„É≥ÔºàÂõûËª¢„Åô„ÇãÁôΩ„ÅÑÂºß„ÇíË™≠„ÅøÂèñ„Çã„Åü„ÇÅÔºâ
            const scanX = Math.floor(centerX + bounds.width * 0.2);
            const scanY = Math.floor(centerY);

            if (scanX >= 0 && scanX < width && scanY >= 0 && scanY < height) {
                const idx = (scanY * width + scanX) * 4;
                const gray = imageData[idx] * 0.299 + imageData[idx + 1] * 0.587 + imageData[idx + 2] * 0.114;

                return {
                    x: scanX,
                    y: scanY,
                    brightness: gray,
                    isWhite: gray > 150,
                    timestamp: Date.now()
                };
            }

            return null;
        }

        function analyzeScanHistory() {
            // „Çπ„Ç≠„É£„É≥Â±•Ê≠¥„Åã„ÇâÂë®ÊúüÁöÑ„Å™„Éë„Çø„Éº„É≥„ÇíÊ§úÂá∫„Åó„Å¶„Éì„ÉÉ„Éà„ÇíÂæ©ÂÖÉ
            if (scanHistory.length < 10) return null;

            // ÊúÄÊñ∞„ÅÆ50„Çµ„É≥„Éó„É´„Çí‰ΩøÁî®
            const recentScans = scanHistory.slice(-50);
            let bitPattern = '';

            // ÁôΩ„ÅÑ„Éî„ÇØ„Çª„É´„ÅÆÊ§úÂá∫„Åã„Çâ„Éì„ÉÉ„ÉàÂàó„ÇíÊßãÊàê
            for (let i = 0; i < recentScans.length - 1; i++) {
                const current = recentScans[i];
                const next = recentScans[i + 1];

                // ÁôΩ‚ÜíÈªí„Åæ„Åü„ÅØÈªí‚ÜíÁôΩ„ÅÆÂ§âÂåñ„ÇíÊ§úÂá∫
                if (current.isWhite && !next.isWhite) {
                    bitPattern += '1';
                } else if (!current.isWhite && current.brightness < 80) {
                    bitPattern += '0';
                }
            }

            return bitPattern.length > 8 ? bitPattern : null;
        }

        function scanDisk() {
            if (!video.videoWidth || !video.videoHeight) return;

            const now = Date.now();
            if (now - lastScanTime < 50) return; // 20FPSÂà∂Èôê
            lastScanTime = now;

            try {
                // „Ç≠„É£„É≥„Éê„Çπ„Å´ÁèæÂú®„ÅÆ„Éï„É¨„Éº„É†„ÇíÊèèÁîª
                debugCanvas.width = video.videoWidth;
                debugCanvas.height = video.videoHeight;
                debugCtx.drawImage(video, 0, 0);

                const imageData = debugCtx.getImageData(0, 0, video.videoWidth, video.videoHeight);

                // „Éï„Ç°„Ç§„É≥„ÉÄ„Éº„Éë„Çø„Éº„É≥„ÇíÊ§úÂá∫
                const finderPatterns = findFinderPatterns(imageData.data, video.videoWidth, video.videoHeight);

                let debugInfo = `Finder patterns found: ${finderPatterns.length}\n`;

                if (debugMode) {
                    // „Éá„Éê„ÉÉ„Ç∞Ë°®Á§∫: Ê§úÂá∫„Åó„Åü„Éë„Çø„Éº„É≥„ÇíÊèèÁîª
                    debugCtx.strokeStyle = 'lime';
                    debugCtx.lineWidth = 2;
                    finderPatterns.forEach((pattern, i) => {
                        debugCtx.strokeRect(pattern.x - pattern.size / 2, pattern.y - pattern.size / 2,
                            pattern.size, pattern.size);
                        debugCtx.fillStyle = 'lime';
                        debugCtx.fillText(`${i}`, pattern.x - 10, pattern.y - 10);
                    });
                }

                if (finderPatterns.length >= 3) {
                    // „Éá„Ç£„Çπ„ÇØÁØÑÂõ≤„ÇíÊäΩÂá∫
                    const bounds = extractDiskBounds(finderPatterns);

                    if (bounds) {
                        // ‰∏ÄÁÇπ„Çπ„Ç≠„É£„É≥ÂÆüË°å
                        const scanResult = scanSinglePoint(imageData.data, video.videoWidth, video.videoHeight, bounds);

                        if (scanResult) {
                            scanHistory.push(scanResult);

                            // Â±•Ê≠¥„ÅåÈï∑„Åô„Åé„ÇãÂ†¥Âêà„ÅØÂè§„ÅÑ„Éá„Éº„Çø„ÇíÂâäÈô§
                            if (scanHistory.length > 100) {
                                scanHistory = scanHistory.slice(-100);
                            }

                            if (debugMode) {
                                // „Çπ„Ç≠„É£„É≥„Éù„Ç§„É≥„Éà„ÇíË°®Á§∫
                                debugCtx.fillStyle = scanResult.isWhite ? 'yellow' : 'red';
                                debugCtx.beginPath();
                                debugCtx.arc(scanResult.x, scanResult.y, 8, 0, Math.PI * 2);
                                debugCtx.fill();

                                // „Éá„Ç£„Çπ„ÇØÂ¢ÉÁïå„ÇíË°®Á§∫
                                debugCtx.strokeStyle = 'cyan';
                                debugCtx.lineWidth = 1;
                                debugCtx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height);
                            }

                            // Â±•Ê≠¥„Åã„Çâ„Éì„ÉÉ„Éà„Éë„Çø„Éº„É≥„ÇíËß£Êûê
                            const detectedBits = analyzeScanHistory();

                            debugInfo += `Scan point: (${scanResult.x}, ${scanResult.y})\n`;
                            debugInfo += `Brightness: ${scanResult.brightness.toFixed(1)}\n`;
                            debugInfo += `History: ${scanHistory.length} samples\n`;

                            if (detectedBits) {
                                debugInfo += `Detected bits: ${detectedBits.substr(0, 32)}...\n`;

                                const decodedText = bitStringToString(detectedBits);

                                if (decodedText.length > 0 && isValidText(decodedText)) {
                                    document.getElementById('scanStatus').className = 'status success';
                                    document.getElementById('scanStatus').textContent =
                                        `‚úÖ Reading disk data... Found ${decodedText.length} characters`;

                                    let resultText = `üéØ Decoded Text: "${decodedText}"\n`;
                                    resultText += `üìä Bit Pattern: ${detectedBits}\n`;
                                    resultText += `‚è∞ Scan Time: ${new Date().toLocaleTimeString()}\n`;
                                    resultText += `üìè Data Length: ${decodedText.length} characters\n`;
                                    resultText += `üîç Scan History: ${scanHistory.length} points\n`;
                                    resultText += `üìç Last Scan: (${scanResult.x}, ${scanResult.y}) brightness=${scanResult.brightness.toFixed(1)}`;

                                    document.getElementById('scannedData').textContent = resultText;
                                } else {
                                    document.getElementById('scanStatus').className = 'status info';
                                    document.getElementById('scanStatus').textContent =
                                        `üîÑ Analyzing pattern... ${detectedBits.length} bits collected`;
                                }
                            } else {
                                document.getElementById('scanStatus').className = 'status info';
                                document.getElementById('scanStatus').textContent =
                                    `üìä Collecting data... ${scanHistory.length} samples`;
                            }
                        }
                    }
                } else {
                    document.getElementById('scanStatus').className = 'status info';
                    document.getElementById('scanStatus').textContent =
                        `üîç Looking for 3 disk markers... Found ${finderPatterns.length}/3`;
                }

                document.getElementById('debugInfo').textContent = debugInfo;

            } catch (error) {
                console.error('Scan error:', error);
                document.getElementById('scanStatus').className = 'status error';
                document.getElementById('scanStatus').textContent = '‚ùå Scan error: ' + error.message;
            }
        }

        function isValidText(text) {
            if (text.length === 0) return false;

            let printableCount = 0;
            for (let i = 0; i < text.length; i++) {
                const code = text.charCodeAt(i);
                if ((code >= 32 && code <= 126) || code === 10 || code === 13) {
                    printableCount++;
                }
            }

            return (printableCount / text.length) > 0.6;
        }

        async function startCamera() {
            try {
                const deviceId = document.getElementById('deviceSelect').value;
                const constraints = {
                    video: {
                        ...(deviceId ? { deviceId } : { facingMode: 'environment' }),
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;

                document.getElementById('scanStatus').className = 'status success';
                document.getElementById('scanStatus').textContent = 'üìπ Camera active - looking for disk...';

                // ËªΩÈáè„Å™20FPS „Çπ„Ç≠„É£„É≥
                scanInterval = setInterval(scanDisk, 50);
                scanHistory = []; // Â±•Ê≠¥„Çí„É™„Çª„ÉÉ„Éà

            } catch (error) {
                document.getElementById('scanStatus').className = 'status error';
                document.getElementById('scanStatus').textContent = '‚ùå Camera failed: ' + error.message;
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            if (scanInterval) {
                clearInterval(scanInterval);
                scanInterval = null;
            }
            scanHistory = [];
            document.getElementById('scanStatus').className = 'status info';
            document.getElementById('scanStatus').textContent = 'üìπ Camera stopped';

            // „Éá„Éê„ÉÉ„Ç∞Ë°®Á§∫„Çí„ÇØ„É™„Ç¢
            if (debugMode) {
                debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            }
            document.getElementById('debugInfo').textContent = '';
        }

        // Initialize camera device list
        async function initializeDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                const select = document.getElementById('deviceSelect');

                select.innerHTML = '<option value="">Default Camera</option>';
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Camera ${index + 1}`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to enumerate devices:', error);
            }
        }

        // Initialize
        updateDiskData();
        animate();
        initializeDevices();

        // Cleanup
        window.addEventListener('beforeunload', () => {
            stopCamera();
            if (animationId) cancelAnimationFrame(animationId);
        });
    </script>
</body>

</html>